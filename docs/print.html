<!DOCTYPE HTML>
<html lang="cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>网络游戏开发运维实操手册</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="游戏服务器架构、游戏服务器运维、游戏开发工具、游戏AI、NavMesh、A*、MMO、Slots">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="简介.html">简介</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">开发篇</li><li class="chapter-item expanded "><a href="开发篇/MMORPG项目.html"><strong aria-hidden="true">1.</strong> MMORPG项目</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="开发篇/MMORPG项目/简介.html"><strong aria-hidden="true">1.1.</strong> 简介</a></li><li class="chapter-item expanded "><a href="开发篇/MMORPG项目/服务器架构.html"><strong aria-hidden="true">1.2.</strong> 架构</a></li><li class="chapter-item expanded "><a href="开发篇/MMORPG项目/核心模块.html"><strong aria-hidden="true">1.3.</strong> 核心模块</a></li><li class="chapter-item expanded "><a href="开发篇/MMORPG项目/压力测试.html"><strong aria-hidden="true">1.4.</strong> 压力测试</a></li></ol></li><li class="chapter-item expanded "><a href="开发篇/Slots项目.html"><strong aria-hidden="true">2.</strong> Slots项目</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="开发篇/Slots项目/简介.html"><strong aria-hidden="true">2.1.</strong> 简介</a></li><li class="chapter-item expanded "><a href="开发篇/Slots项目/服务器架构.html"><strong aria-hidden="true">2.2.</strong> 架构</a></li><li class="chapter-item expanded "><a href="开发篇/Slots项目/核心模块.html"><strong aria-hidden="true">2.3.</strong> 核心模块</a></li><li class="chapter-item expanded "><a href="开发篇/Slots项目/压力测试.html"><strong aria-hidden="true">2.4.</strong> 压力测试</a></li></ol></li><li class="chapter-item expanded "><a href="开发篇/人工智能.html"><strong aria-hidden="true">3.</strong> 人工智能</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="开发篇/人工智能/寻路系统.html"><strong aria-hidden="true">3.1.</strong> 寻路系统</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="开发篇/人工智能/寻路系统/A星算法.html"><strong aria-hidden="true">3.1.1.</strong> A*算法</a></li><li class="chapter-item expanded "><a href="开发篇/人工智能/寻路系统/NavMesh网格.html"><strong aria-hidden="true">3.1.2.</strong> NavMesh网格</a></li><li class="chapter-item expanded "><a href="开发篇/人工智能/寻路系统/图形显示工具.html"><strong aria-hidden="true">3.1.3.</strong> 图形显示工具</a></li></ol></li><li class="chapter-item expanded "><a href="开发篇/人工智能/游戏AI.html"><strong aria-hidden="true">3.2.</strong> 游戏AI</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="开发篇/人工智能/游戏AI/状态机.html"><strong aria-hidden="true">3.2.1.</strong> 状态机</a></li><li class="chapter-item expanded "><a href="开发篇/人工智能/游戏AI/行为树.html"><strong aria-hidden="true">3.2.2.</strong> 行为树</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="开发篇/Excel导表.html"><strong aria-hidden="true">4.</strong> Excel导表</a></li><li class="chapter-item expanded "><a href="开发篇/压力测试.html"><strong aria-hidden="true">5.</strong> 压力测试</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="开发篇/压力测试/Http压测.html"><strong aria-hidden="true">5.1.</strong> Http压测</a></li><li class="chapter-item expanded "><a href="开发篇/压力测试/Tcp压测.html"><strong aria-hidden="true">5.2.</strong> Tcp压测</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">运维篇</li><li class="chapter-item expanded "><a href="运维篇/Linux.html"><strong aria-hidden="true">6.</strong> Linux</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="运维篇/Linux/CentOS命令参考.html"><strong aria-hidden="true">6.1.</strong> CentOS命令参考</a></li><li class="chapter-item expanded "><a href="运维篇/Linux/CentOS软件安装.html"><strong aria-hidden="true">6.2.</strong> CentOS软件安装</a></li><li class="chapter-item expanded "><a href="运维篇/Linux/CentOS环境配置.html"><strong aria-hidden="true">6.3.</strong> CentOS环境配置</a></li></ol></li><li class="chapter-item expanded "><a href="运维篇/开发工具.html"><strong aria-hidden="true">7.</strong> 开发工具</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="运维篇/开发工具/Git.html"><strong aria-hidden="true">7.1.</strong> Git</a></li><li class="chapter-item expanded "><a href="运维篇/开发工具/Gitlab.html"><strong aria-hidden="true">7.2.</strong> Gitlab</a></li><li class="chapter-item expanded "><a href="运维篇/开发工具/Maven.html"><strong aria-hidden="true">7.3.</strong> Maven</a></li><li class="chapter-item expanded "><a href="运维篇/开发工具/Nexus.html"><strong aria-hidden="true">7.4.</strong> Nexus</a></li><li class="chapter-item expanded "><a href="运维篇/开发工具/Nps.html"><strong aria-hidden="true">7.5.</strong> Nps</a></li></ol></li><li class="chapter-item expanded "><a href="运维篇/项目部署.html"><strong aria-hidden="true">8.</strong> 项目部署</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="运维篇/项目部署/Docker.html"><strong aria-hidden="true">8.1.</strong> Docker</a></li><li class="chapter-item expanded "><a href="运维篇/项目部署/Jenkins.html"><strong aria-hidden="true">8.2.</strong> Jenkins</a></li></ol></li><li class="chapter-item expanded "><a href="运维篇/数据库.html"><strong aria-hidden="true">9.</strong> 数据库</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="运维篇/数据库/MongoDB.html"><strong aria-hidden="true">9.1.</strong> MongoDB</a></li><li class="chapter-item expanded "><a href="运维篇/数据库/Redis.html"><strong aria-hidden="true">9.2.</strong> Redis</a></li><li class="chapter-item expanded "><a href="运维篇/数据库/Elasticsearch.html"><strong aria-hidden="true">9.3.</strong> Elasticsearch</a></li></ol></li><li class="chapter-item expanded "><a href="运维篇/监控系统.html"><strong aria-hidden="true">10.</strong> 监控系统</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="运维篇/监控系统/Grafana.html"><strong aria-hidden="true">10.1.</strong> Grafana</a></li><li class="chapter-item expanded "><a href="运维篇/监控系统/InfluxDB.html"><strong aria-hidden="true">10.2.</strong> InfluxDB</a></li><li class="chapter-item expanded "><a href="运维篇/监控系统/Skywalking.html"><strong aria-hidden="true">10.3.</strong> Skywalking</a></li><li class="chapter-item expanded "><a href="运维篇/监控系统/Sentry.html"><strong aria-hidden="true">10.4.</strong> Sentry</a></li></ol></li><li class="chapter-item expanded "><a href="运维篇/诊断工具.html"><strong aria-hidden="true">11.</strong> 诊断工具</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="运维篇/诊断工具/Arthas.html"><strong aria-hidden="true">11.1.</strong> Arthas</a></li></ol></li><li class="chapter-item expanded "><a href="运维篇/三方组件.html"><strong aria-hidden="true">12.</strong> 三方组件</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="运维篇/三方组件/Nginx1.html"><strong aria-hidden="true">12.1.</strong> Nginx</a></li><li class="chapter-item expanded "><a href="运维篇/三方组件/Zookeeper.html"><strong aria-hidden="true">12.2.</strong> Zookeeper</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">网络游戏开发运维实操手册</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/jzyong/GameDevAndOps" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="简介"><a class="header" href="#简介">简介</a></h1>
<p>  结合自身工作经历写的网络游戏服务器开发相关技术，服务器运维部署相关技术。
编写目的主要是进行服务器技术总结、分享、备忘、指令快速查找。全书总共分为开发篇、运维篇两个部分。
项目开发语言主要是Java，部分项目为Go，C#，同时涉及Shell脚本，Unity等相关技术。
本书不过多介绍理论知识，更多的是介绍实际项目中使用到的技术，框架，常用命令介绍、备忘等，相关技术会贴出官方文档或参考文档地址。</p>
<h2 id="开发篇"><a class="header" href="#开发篇">开发篇</a></h2>
<p>  前两章介绍在实际开发中的两个游戏项目，架构和使用的相关技术，MMORPG项目采用分区分服架构，slots项目采用全区全服架构。
第三章介绍服务器端开发RPG游戏使用的AI技术；第四章介绍如何将Unity中的NavMesh+A*寻路算法运用于服务器；第五章介绍excel导表工具；第六章介绍服务器压测集群。</p>
<ul>
<li><a href="%E5%BC%80%E5%8F%91%E7%AF%87/MMORPG%E9%A1%B9%E7%9B%AE.html">MMORPG项目</a></li>
<li><a href="%E5%BC%80%E5%8F%91%E7%AF%87/Slots%E9%A1%B9%E7%9B%AE.html">Slots项目</a></li>
<li><a href="%E5%BC%80%E5%8F%91%E7%AF%87/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%B8%B8%E6%88%8FAI.html">游戏AI</a></li>
<li><a href="%E5%BC%80%E5%8F%91%E7%AF%87/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F.html">寻路系统</a></li>
<li><a href="%E5%BC%80%E5%8F%91%E7%AF%87/Excel%E5%AF%BC%E8%A1%A8.html">Excel导表</a></li>
<li><a href="%E5%BC%80%E5%8F%91%E7%AF%87/%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95.html">压力测试</a></li>
</ul>
<h2 id="运维篇"><a class="header" href="#运维篇">运维篇</a></h2>
<p>   第一章介绍生产环境Linux参数调优，各种软件安装，环境配置；第二章介绍开发中使用的工具部署，使用；第三章介绍项目在开发、生产环境中的CI/CD;第四章介绍数据库的部署，维护，常用指令；
第五章介绍服务器、进程服务的监控与预警；第六章介绍线上运行程序的诊断，问题排查处理；第七章介绍一些其他常用组件的部署运维。</p>
<ul>
<li><a href="%E8%BF%90%E7%BB%B4%E7%AF%87/Linux.html">Linux</a></li>
<li><a href="%E8%BF%90%E7%BB%B4%E7%AF%87/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7.html">开发工具</a></li>
<li><a href="%E8%BF%90%E7%BB%B4%E7%AF%87/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2.html">项目部署</a></li>
<li><a href="%E8%BF%90%E7%BB%B4%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93.html">数据库</a></li>
<li><a href="%E8%BF%90%E7%BB%B4%E7%AF%87/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F.html">监控系统</a></li>
<li><a href="%E8%BF%90%E7%BB%B4%E7%AF%87/%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7.html">诊断工具</a></li>
<li><a href="%E8%BF%90%E7%BB%B4%E7%AF%87/%E4%B8%89%E6%96%B9%E7%BB%84%E4%BB%B6.html">三方组件</a></li>
</ul>
<p>技术交流学习359135103@qq.com</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mmorpg项目"><a class="header" href="#mmorpg项目">MMORPG项目</a></h1>
<p>  MMORPG大型多人在线角色扮演游戏，本人在实际工作中采用的分区分服架构,Java开发的多进程服务器。
此章节主要总结一下MMORPG常用的技术，服务器架构的搭建，核心功能模块的设计、编写以及怎样进行压力测试以保证承载，延迟问题。</p>
<ul>
<li><a href="%E5%BC%80%E5%8F%91%E7%AF%87/MMORPG%E9%A1%B9%E7%9B%AE/%E7%AE%80%E4%BB%8B.html">简介</a></li>
<li><a href="%E5%BC%80%E5%8F%91%E7%AF%87/MMORPG%E9%A1%B9%E7%9B%AE/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84.html">架构</a></li>
<li><a href="%E5%BC%80%E5%8F%91%E7%AF%87/MMORPG%E9%A1%B9%E7%9B%AE/%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97.html">核心模块</a></li>
<li><a href="%E5%BC%80%E5%8F%91%E7%AF%87/MMORPG%E9%A1%B9%E7%9B%AE/%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95.html">压力测试</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简介-1"><a class="header" href="#简介-1">简介</a></h1>
<p>  介绍一款修仙类MMORPG手游服务器实现，游戏是分区分服，架构采用分布式多进程搭建。
客户端采用Unity开发，服务开发技术主要是Java，单服务器线上实跑真实玩家2000+，机器人压测实跑5000+。</p>
<h2 id="技术选型"><a class="header" href="#技术选型">技术选型</a></h2>
<p>  服务器使用Java版本为Jdk8，未过多使用第三方组件，基本上是自己封装。
数据库MongoDB存储玩家数据，MySQL存储策划配置文件，Redis存储排行榜及部分缓存数据。
使用Git、Jenkins、Nexus搭建测试环境，持续集成，持续部署。
Github类似开源服务器框架<a href="https://github.com/jzyong/game-server">GameServer</a>。</p>
<ul>
<li>编程：Java</li>
<li>数据库：MongoDB、MySQL、Redis</li>
<li>网络库：Netty、ProtoBuf</li>
<li>项目构建：Maven</li>
<li>开发工具：Git、Jenkins、Nexus</li>
<li>生产环境：Centos</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="架构"><a class="header" href="#架构">架构</a></h1>
<p>  服务器采用多进程进行架构，客户端到网关、内部通信使用自定义TCP进行网络通信（Netty+Protobuf），后台管理系统调用查询使用HTTP协议。整体架构如下所示</p>
<p><img src="%E5%BC%80%E5%8F%91%E7%AF%87/MMORPG%E9%A1%B9%E7%9B%AE/img/mmo_architecture.png" alt="服务器架构" /></p>
<h2 id="登录服"><a class="header" href="#登录服">登录服</a></h2>
<p>  登录服可水平扩展，兼容了类似zookeeper的服务发现功能，游戏服、网关服启动时会向所有的登录服进行注册，同时可管理他们的运行状态。
主要功能如下：</p>
<ul>
<li>登录校验</li>
<li>获取游戏服务器列表</li>
<li>获取网关列表</li>
<li>网关服、游戏服状态管理</li>
</ul>
<p>  玩家首次打开游戏APP通过通过HTTP请求网关列表，登录服返回空闲的网关地址；
APP使用返回的地址向网关进行TCP连接，然后进行登录校验，获取游戏大区列表，玩家选择登录游戏逻辑服。后续所有客户端请求TCP消息都通过网关服转发，时序图如下所示：<br />
<img src="%E5%BC%80%E5%8F%91%E7%AF%87/MMORPG%E9%A1%B9%E7%9B%AE/img/mmo_login.png" alt="登录流程图" /></p>
<h2 id="网关服"><a class="header" href="#网关服">网关服</a></h2>
<p>  网关服也是水平扩展的，连接登陆服、游戏逻辑服、世界服，负责各自消息的转发，主要功能如下：</p>
<ul>
<li>网络消息的转发</li>
<li>玩家连接会话管理</li>
<li>消息合并</li>
<li>数据加解密</li>
<li>数据压缩、解压缩</li>
<li>玩家通信频率限制，IP黑名单处理</li>
</ul>
<p>  玩家登录选择游戏服后，会在网关绑定玩家登录的游戏服连接会话，以后所有消息都转发到对应该游戏服。
网络消息转发通过为每个消息定义一个消息ID进行转发。如果消息ID是注册在游戏逻辑服，就将相应的消息转发给游戏逻辑服。</p>
<p>  消息合并是将游戏逻辑服同一时间同一玩家的多条返回消息合并成一个消息转发给客户端，减少网络延迟，丢包重发等。
消息合并不超过MTU，且必须设置超时时间。数据加解密使用对称加密算法RC4，创建Socket时服务器返回一个密钥字符串。
数据压缩使用Snappy进行压缩，且只对消息长度超过MTU的部分数据进行压缩。
通信频率限制，IP黑名单主要是针对非法玩家使用加速器的请求，篡改协议等做出相应的限制。</p>
<h3 id="协议定义"><a class="header" href="#协议定义">协议定义</a></h3>
<h4 id="用户到网关"><a class="header" href="#用户到网关">用户到网关</a></h4>
<p>  用户到网关的协议格式如下，其中消息长度第30位标识是否加密，29位标识是否压缩，后二十位表示真正的消息长度。</p>
<pre><code>消息长度[4]+消息ID[4]+Protobuf字节流
</code></pre>
<h4 id="网关和内部进程"><a class="header" href="#网关和内部进程">网关和内部进程</a></h4>
<p>  网关到内部进程服务协议增加了玩家ID，需要知道每条消息归属于那个玩家。</p>
<pre><code class="language-shell script">消息长度[4]+消息ID[4]+玩家ID[8]+Protobuf字节流
</code></pre>
<h2 id="游戏服"><a class="header" href="#游戏服">游戏服</a></h2>
<p>  一个游戏服是一个独立的游戏世界，玩家所有游戏操作相关的逻辑都在游戏服进行处理。多个游戏地图场景在一个游戏服中使用多线程处理，没有按照地图进行创建进程。
核心功能模块参考<a href="%E5%BC%80%E5%8F%91%E7%AF%87/MMORPG%E9%A1%B9%E7%9B%AE/%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97.html">下一节</a>，主要功能模块有：</p>
<ul>
<li>武器、宠物、镶嵌、法宝、成就、称号、境界、坐骑、翅膀、时装等养成系统</li>
<li>公会、好友、组队、邮件、聊天、师徒、结婚等社交系统</li>
<li>背包、仓库、商城、交易、摆摊等系统</li>
<li>野外场景、战场、副本等系统</li>
<li>AI、寻路、技能、Buff等系统</li>
<li>活动系统</li>
</ul>
<h2 id="日志服"><a class="header" href="#日志服">日志服</a></h2>
<p>  日志服也是水平扩展的，游戏服在多个可用日志服中随机选择一个进行日志传送。
日志服主要功能是将所有收到的消息批量写入MySQL数据库，供后台系统进行处理。</p>
<h2 id="充值服"><a class="header" href="#充值服">充值服</a></h2>
<p>  充值服也是水平扩展的，主要是功能是验证第三方充值的合法性。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="核心模块"><a class="header" href="#核心模块">核心模块</a></h1>
<p>  此小节主要介绍MMORPG游戏中的关键技术、特性及注意事项，主要模块有：</p>
<ul>
<li>线程模型</li>
<li>热更新</li>
<li>地图战斗</li>
</ul>
<h2 id="线程模型"><a class="header" href="#线程模型">线程模型</a></h2>
<p>  因为服务器采用的是多进程多线程模型，因此线程模型未设计好，经常会出现各种bug和性能问题。
经过多次实践借鉴最终基于netty的线程模型进行了封装，源码可参考<a href="https://github.com/jzyong/javalib/tree/main/javalib-network/src/main/java/com/jzy/javalib/network/scene">javaLib</a> 。
采用n个线程对应m个队列，一个线程可绑定多个队列，一个队列可以是一个功能模块，比如公会可分配一个队列绑定到唯一的线程，如下图所示：</p>
<p><img src="%E5%BC%80%E5%8F%91%E7%AF%87/MMORPG%E9%A1%B9%E7%9B%AE/img/mmo_thread.png" alt="thread" /></p>
<pre><code>//场景线程组
SceneLoopGroup sceneLoopGroup = new SceneTaskLoopGroup();
//全局线程组
SceneLoopGroup soleLoopGroup = new SceneTaskLoopGroup();

//注册
SceneLoop sceneLoop = soleLoopGroup.next();

//teamScene 是实现了Scene接口的TeamManager单例对象
teamScene.register(sceneLoop);
guildScene.register(sceneLoop);
...
</code></pre>
<p>  上面示例代码<code>SceneTaskLoopGroup</code>等价于Netty的<code>NioEventLoopGroup</code>,<code>Scene</code>等价于Netty的<code>Channel</code>。
全局所有玩家操作的对象如公会，聊天，组队等都单独创建一个独立的队列，所有玩家该功能模块的操作都丢人该队列中执行；
野外场景，副本的创建也单独创建一个队列，在同一场景、副本的玩家操作在同一队列中执行。</p>
<h2 id="热更新"><a class="header" href="#热更新">热更新</a></h2>
<p>  热更新使用Java自带的<code>JavaCompiler</code>将源文件编译成class文件，然后使用<code>ClassLoader</code>将class文件加载到内存中，
源码及示例可参考<a href="https://github.com/jzyong/GameServer4j">GameServer4j</a> 。
此方法优点是使用java原生代码，开发简单方便;缺点是只能更新部分逻辑，如数据存储实体类不能进行热更新，逻辑必须实现接口。
大致流程如下：</p>
<p><img src="%E5%BC%80%E5%8F%91%E7%AF%87/MMORPG%E9%A1%B9%E7%9B%AE/img/mmo_script.png" alt="Script update flow" /></p>
<h2 id="地图战斗"><a class="header" href="#地图战斗">地图战斗</a></h2>
<h3 id="地图设计"><a class="header" href="#地图设计">地图设计</a></h3>
<ol>
<li>地图分为野外地图、副本、战场、公会地图等，其中野外地图又按人数分多线。</li>
<li>每个地图都绑定一个消息队列，同一地图的玩家操作，战斗都在同一线程执行。</li>
<li>每个地图都有定时器进行AI、技能的定时计算。</li>
<li>地图划分主要有两种，一种是为了进行视野同步（九宫格）将地图分成大小相同的多个矩形格子，
另一种是四叉树划分行走面的凸多边形（快速查询地图对象所在行走面的凸多边形）。
<img src="%E5%BC%80%E5%8F%91%E7%AF%87/MMORPG%E9%A1%B9%E7%9B%AE/img/mmo_map.png" alt="Map divide" /></li>
</ol>
<h3 id="技能设计"><a class="header" href="#技能设计">技能设计</a></h3>
<p>  技能、AI目标筛选也只针对九宫格中的对象进行寻找，方式分为矩形，圆形，扇形等。
矩形目标筛选通过玩家朝向构建一个矩形，然后判断周围的对象是否在矩形中；圆形直接判断周围对象的距离；扇形构建多个三角形，判断周围对象是否在三角形中。
<img src="%E5%BC%80%E5%8F%91%E7%AF%87/MMORPG%E9%A1%B9%E7%9B%AE/img/mmo_skill_target.png" alt="Skill target" /></p>
<h3 id="ai寻路"><a class="header" href="#ai寻路">AI、寻路</a></h3>
<ul>
<li>AI 使用<a href="%E5%BC%80%E5%8F%91%E7%AF%87/MMORPG%E9%A1%B9%E7%9B%AE/../%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%B8%B8%E6%88%8FAI/%E7%8A%B6%E6%80%81%E6%9C%BA.html">状态机</a>和<a href="%E5%BC%80%E5%8F%91%E7%AF%87/MMORPG%E9%A1%B9%E7%9B%AE/../%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%B8%B8%E6%88%8FAI/%E8%A1%8C%E4%B8%BA%E6%A0%91.html">行为树</a></li>
<li>寻路使用<a href="%E5%BC%80%E5%8F%91%E7%AF%87/MMORPG%E9%A1%B9%E7%9B%AE/../%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/A%E6%98%9F%E7%AE%97%E6%B3%95.html">A*</a>和<a href="%E5%BC%80%E5%8F%91%E7%AF%87/MMORPG%E9%A1%B9%E7%9B%AE/../%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/NavMesh%E7%BD%91%E6%A0%BC.html">NavMesh</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="压力测试"><a class="header" href="#压力测试">压力测试</a></h1>
<h2 id="压测结果"><a class="header" href="#压测结果">压测结果</a></h2>
<ul>
<li>单服务器可承载5000+</li>
<li>同一场景地图可承载1000+对象（玩家+NPC）寻路释放技能</li>
</ul>
<h2 id="测试目的"><a class="header" href="#测试目的">测试目的</a></h2>
<ul>
<li>模拟真实玩家行为，发现服务器高并发下的问题</li>
<li>测试服务器的承载压力</li>
<li>分析优化网络，消息包</li>
<li>测试各个功能模块</li>
<li>分析技能、NPC AI，寻路等高频执行逻辑性能问题</li>
<li>协助客户端排查性能问题，同步显示对象数，渲染性能问题</li>
</ul>
<h2 id="实现技术"><a class="header" href="#实现技术">实现技术</a></h2>
<ul>
<li><strong>Netty</strong>：网络通信</li>
<li><strong>A星+NavMesh</strong>：玩家寻路</li>
<li><strong>行为树</strong>：玩家逻辑组装</li>
<li><strong>Libgdx</strong>：图形界面显示</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="slots项目"><a class="header" href="#slots项目">Slots项目</a></h1>
<p>  Slots主要是针对欧美的休闲游戏，本人在实际工作中采用的微服务架构,Java+Go开发的混合型服务器。
此章节主要总结一下Slots游戏开发中常使用的技术，服务器架构的搭建，核心功能模块的设计、编写以及怎样进行压力测试以保证承载，延迟问题。</p>
<ul>
<li><a href="%E5%BC%80%E5%8F%91%E7%AF%87/Slots%E9%A1%B9%E7%9B%AE/%E7%AE%80%E4%BB%8B.html">简介</a></li>
<li><a href="%E5%BC%80%E5%8F%91%E7%AF%87/Slots%E9%A1%B9%E7%9B%AE/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84.html">架构</a></li>
<li><a href="%E5%BC%80%E5%8F%91%E7%AF%87/Slots%E9%A1%B9%E7%9B%AE/%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97.html">核心模块</a></li>
<li><a href="%E5%BC%80%E5%8F%91%E7%AF%87/Slots%E9%A1%B9%E7%9B%AE/%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95.html">压力测试</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简介-2"><a class="header" href="#简介-2">简介</a></h1>
<p>  介绍一款Slots手游服务器实现，游戏是全区全服，架构采用微服务搭建。
客户端采用Unity开发，服务开发语言主要是Java和Go。</p>
<h2 id="技术选型-1"><a class="header" href="#技术选型-1">技术选型</a></h2>
<p>  服务器使用Java版本为<code>Jdk14</code>，Go版本为<code>1.14.3</code>。
Java开发游戏主要功能逻辑，Go开发周边功能及工具，Unity开发内部图形化工具，shell开发CI/CD脚本。
数据库MongoDB存储玩家数据和策划配置文件，Redis存储排行榜及部分缓存数据。
使用Git、Jenkins、Nexus、Docker搭建测试环境，持续集成，持续部署。
Sentry监控代码异常，InfluxDB监控数据库、Docker、Linux主机等资源占用，Elasticsearch实现日志集中查询，
Skywalking监控Java进程信息，Grafana+钉钉实现监控图形化和预警通知。
Github类似开源服务器框架<a href="https://github.com/jzyong/GameServer4j">GameServer4j</a>。</p>
<ul>
<li>编程：Java、Go、C#、Shell</li>
<li>图形：Unity</li>
<li>数据库：MongoDB、Redis</li>
<li>网络库：Netty、ProtoBuf、Grpc</li>
<li>开发工具：Git、Jenkins、Nexus、Gitlab、Maven</li>
<li>生产环境：Centos、Docker、Elasticsearch、Nginx</li>
<li>监控：Grafana、InfluxDB、Sentry、Skywalking、钉钉</li>
<li>第三方组件：Springboot、Zookeeper</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="服务器架构"><a class="header" href="#服务器架构">服务器架构</a></h1>
<p>  服务器采用微服务进行架构，客户端到网关使用自定义TCP进行网络通信（Netty+Protobuf），内部通信使用grpc，
后台管理系统调用查询使用HTTP协议。服务配置，服务发现使用zookeeper进行管理。整体架构如下所示：</p>
<p><img src="%E5%BC%80%E5%8F%91%E7%AF%87/Slots%E9%A1%B9%E7%9B%AE/img/slots_architecture.png" alt="架构图" /></p>
<h2 id="api服"><a class="header" href="#api服">API服</a></h2>
<p>  API可水平扩展，主要功能如下：</p>
<ul>
<li>注册、登录校验</li>
<li>充值校验</li>
</ul>
<p>  玩家首次打开游戏APP通过HTTP向Manage服获取网关列表；
客户端使用返回的地址向网关进行TCP连接；然后向Api服进行登录校验或用户注册；如果校验失败直接经网关返回客户端，否则将信息经网关再发送给大厅服请求加载玩家数据。
后续所有客户端请求TCP消息都通过网关服转发，时序图如下所示：</p>
<p><img src="%E5%BC%80%E5%8F%91%E7%AF%87/Slots%E9%A1%B9%E7%9B%AE/img/slots_login.png" alt="登录流程图" /></p>
<h2 id="网关服-1"><a class="header" href="#网关服-1">网关服</a></h2>
<p>  网关服也是水平扩展的，连接API服、大厅服、Slots小游戏服，负责各自消息的转发，主要功能如下：</p>
<ul>
<li>网络消息的转发</li>
<li>玩家连接会话管理</li>
<li>消息合并</li>
<li>数据加解密</li>
<li>数据压缩、解压缩</li>
<li>玩家通信频率限制，IP黑名单处理</li>
</ul>
<p>  玩家登录选择游戏服后，会在网关绑定玩家登录的游戏服连接会话，以后所有消息都转发到对应该游戏服。
网络消息转发通过为每个消息定义一个消息ID进行转发。如果消息ID是注册在大厅服，就将相应的消息转发给大厅服。</p>
<p>  消息合并是将游戏逻辑服同一时间同一玩家的多条返回消息合并成一个消息转发给客户端，减少网络延迟，丢包重发等。
消息合并不超过MTU，且必须设置超时时间。数据加解密使用对称加密算法RC4，创建Socket时服务器返回一个密钥字符串。
数据压缩使用Snappy进行压缩，且只对消息长度超过MTU的部分数据进行压缩。
通信频率限制，IP黑名单主要是针对非法玩家使用加速器的请求，篡改协议等做出相应的限制。</p>
<h3 id="协议定义-1"><a class="header" href="#协议定义-1">协议定义</a></h3>
<p>   用户到网关，网关到大厅、Slots服使用自定义TCP协议进行通信，其他服务器互联使用标准的grpc连接。</p>
<h4 id="用户到网关-1"><a class="header" href="#用户到网关-1">用户到网关</a></h4>
<pre><code>消息长度[4]+消息ID[4]+确认消息最小序列号[4]+消息序号[4]+Protobuf字节流
</code></pre>
<p>  用户到网关的协议其中消息长度第30位标识是否加密，29位标识是否压缩，后二十位表示真正的消息长度；
消息序号用来确定每个消息的唯一性，客户端自增长，确认消息序列号是客户端收到的请求消息最小序列号；
消息序号用于判断客户端重复请求，同一序号只能被后台服务器执行一次，网关会进行返回消息缓存，如果客户端请求消息序号网关有缓存，直接从缓存消息返回结果，比如断线重连；
服务器收到确认消息最小序号就将网关缓存的所有小于改序号的缓存消息清除掉，表示客户端不再需要该消息。流程图如下所示：</p>
<p><img src="%E5%BC%80%E5%8F%91%E7%AF%87/Slots%E9%A1%B9%E7%9B%AE/img/slots_message_flow.png" alt="消息流程图" /></p>
<h4 id="网关和内部进程-1"><a class="header" href="#网关和内部进程-1">网关和内部进程</a></h4>
<pre><code class="language-shell script">消息长度[4]+消息ID[4]+玩家ID[8]+消息序号[4]+Protobuf字节流
</code></pre>
<p>  网关到内部进程服务协议增加了玩家ID，需要知道每条消息归属于那个玩家。</p>
<h2 id="大厅服"><a class="header" href="#大厅服">大厅服</a></h2>
<p>  大厅服是可水平扩展的有状态逻辑服务器，每个玩家登录都会在网关绑定一个大厅，同一玩家只能在同一大厅处理自身逻辑。
大厅逻辑不会涉及玩家间的交互逻辑，如公会，聊天则会转发到世界服进行逻辑处理。
核心功能模块参考<a href="%E5%BC%80%E5%8F%91%E7%AF%87/Slots%E9%A1%B9%E7%9B%AE/%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97.html">下一节</a>，大厅主要功能模块有：</p>
<ul>
<li>任务、收集、宠物、成就等养成系统</li>
<li>好友、邮件</li>
<li>活动</li>
</ul>
<h2 id="世界服"><a class="header" href="#世界服">世界服</a></h2>
<p>  世界服是单点有状态服务器，主要处理多个玩家有交互的逻辑，主要功能模块有：</p>
<ul>
<li>公会</li>
<li>聊天</li>
</ul>
<h2 id="slots服"><a class="header" href="#slots服">Slots服</a></h2>
<p>  Slots服是各种slots小游戏，每个小游戏是单独的有状态微服务。
Slots服和网关采用自定义TCP协议通信，和大厅采用grpc通信。
slots服只编写游戏逻辑，公共处理逻辑调用大厅rpc。</p>
<h2 id="manage服"><a class="header" href="#manage服">Manage服</a></h2>
<p>  Manage是无状态的HTTP服务，采用SpringBoot搭建的web框架。
可水平扩展，采用Nginx做负载均衡，内部采用grpc和所有服务进行通信。主要功能如下：</p>
<ul>
<li>客户端获取网关IP地址</li>
<li>后台查询修改玩家信息入口</li>
<li>服务器管理入口（加载脚本、配置、关服等）</li>
</ul>
<h2 id="微服务"><a class="header" href="#微服务">微服务</a></h2>
<p>  微服务主要采用Go语言开发，主机是解决Java进程占用内存较大问题，同时开发速度快。
微服务设计目的主要是为了分割世界服这种有状态的单点逻辑。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="核心模块-1"><a class="header" href="#核心模块-1">核心模块</a></h1>
<p>  此小节主要介绍Slots游戏中的关键技术、特性及注意事项，主要模块有：</p>
<ul>
<li>线程模型</li>
<li>热更新</li>
<li>CI/CD</li>
</ul>
<h2 id="线程模型-1"><a class="header" href="#线程模型-1">线程模型</a></h2>
<p>  线程模型和<a href="%E5%BC%80%E5%8F%91%E7%AF%87/Slots%E9%A1%B9%E7%9B%AE/../MMORPG%E9%A1%B9%E7%9B%AE/%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97.html">MMORPG线程模型</a>模型类似，源码可参考<a href="https://github.com/jzyong/javalib/tree/main/javalib-network/src/main/java/com/jzy/javalib/network/scene">javaLib</a> 。
采用n个线程对应m个队列，一个线程可绑定多个队列，一个队列可以是一个功能模块，比如公会可分配一个队列绑定到唯一的线程。因为玩家操作基本无互操作，因此每个玩家都分配了一个队列，所有玩家操作都在自身队列执行，如下图所示：<br />
<img src="%E5%BC%80%E5%8F%91%E7%AF%87/Slots%E9%A1%B9%E7%9B%AE/img/slots_thread.png" alt="线程模型" /></p>
<h2 id="热更新-1"><a class="header" href="#热更新-1">热更新</a></h2>
<p>  热更新方式同MMORPG项目一致，参考<a href="%E5%BC%80%E5%8F%91%E7%AF%87/Slots%E9%A1%B9%E7%9B%AE/../MMORPG%E9%A1%B9%E7%9B%AE/%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97.html">MMORPG热更新</a>。</p>
<h2 id="cicd"><a class="header" href="#cicd">CI/CD</a></h2>
<p>  因为服务器采用微服务架构，进程数上百个，因此采用Docker部署，然后结合jenkins一键部署，加快部署流程。具体搭建技术使用可参考后面的运维篇。</p>
<h3 id="测试环境"><a class="header" href="#测试环境">测试环境</a></h3>
<p>  测试环境运行比较简单，直接在Jenkins中运行项目，更新流程如下：</p>
<p><img src="%E5%BC%80%E5%8F%91%E7%AF%87/Slots%E9%A1%B9%E7%9B%AE/img/slots_test_cd_flow.png" alt="测试更新流程" /></p>
<h3 id="生产环境"><a class="header" href="#生产环境">生产环境</a></h3>
<p>  生产环境服务运行于Docker中，在Jenkins中启动、构建项目、镜像制作，
然后利用私有Docker Register和Docker远程命令执行一键部署。
因为服务都是有状态服务，因此不能直接杀进程，在拉取镜像后，使用后台HTTP调用关闭服务器，确保所有数据都被持久化。
具体更新流程如下：</p>
<p><img src="%E5%BC%80%E5%8F%91%E7%AF%87/Slots%E9%A1%B9%E7%9B%AE/img/slots_product_cd_flow.png" alt="测试更新流程" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="压力测试-1"><a class="header" href="#压力测试-1">压力测试</a></h1>
<p>  因测试环境没有足够的主机，只压测到最高同时在线6000人，两个网关服、两个大厅服、两个API服、两个Manage服和若干子游戏服。
<a href="%E5%BC%80%E5%8F%91%E7%AF%87/Slots%E9%A1%B9%E7%9B%AE/../%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/Http%E5%8E%8B%E6%B5%8B.html">HTTP后台</a>使用Locust测试，最高并发2000QPS；
游戏因为使用TCP自定义协议，因此用Go自行写了<a href="%E5%BC%80%E5%8F%91%E7%AF%87/Slots%E9%A1%B9%E7%9B%AE/../%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/Tcp%E5%8E%8B%E6%B5%8B.html">压测集群</a>，模拟客户端发送消息，最高5000QPS。</p>
<h2 id="测试目的-1"><a class="header" href="#测试目的-1">测试目的</a></h2>
<ul>
<li>模拟真实玩家行为，发现服务器高并发下的问题</li>
<li>测试服务器的承载压力</li>
<li>分析优化网络，消息包</li>
<li>测试各个功能模块</li>
</ul>
<h2 id="实现技术-1"><a class="header" href="#实现技术-1">实现技术</a></h2>
<ul>
<li><strong>Go</strong>：开发压测集群</li>
<li><strong>Unity</strong>：开发压测客户端工具</li>
<li><strong>Locust</strong>：Python实现的HTTP压测工具</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="人工智能"><a class="header" href="#人工智能">人工智能</a></h1>
<p>  此章节主要包含寻路系统和AI两部分，总结自己在开发MMORPG中服务器怎样实现NPC寻路和AI行为。
所有代码使用Java开发，源码参考<a href="https://github.com/jzyong/GameAI4j">GameAI4j</a> ，
Unity NavMesh导出工具参考<a href="https://github.com/jzyong/NavMeshDemo">NavMeshDemo</a> 。</p>
<ul>
<li><a href="%E5%BC%80%E5%8F%91%E7%AF%87/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F.html">寻路系统</a>
<ul>
<li><a href="%E5%BC%80%E5%8F%91%E7%AF%87/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/A%E6%98%9F%E7%AE%97%E6%B3%95.html">A*算法</a></li>
<li><a href="%E5%BC%80%E5%8F%91%E7%AF%87/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/NavMesh%E7%BD%91%E6%A0%BC.html">NavMesh网格</a></li>
<li><a href="%E5%BC%80%E5%8F%91%E7%AF%87/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E5%AF%BB%E8%B7%AF%E7%B3%BB%E7%BB%9F/%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E5%B7%A5%E5%85%B7.html">图形显示工具</a></li>
</ul>
</li>
<li><a href="%E5%BC%80%E5%8F%91%E7%AF%87/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%B8%B8%E6%88%8FAI.html">游戏AI</a>
<ul>
<li><a href="%E5%BC%80%E5%8F%91%E7%AF%87/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%B8%B8%E6%88%8FAI/%E7%8A%B6%E6%80%81%E6%9C%BA.html">状态机</a></li>
<li><a href="%E5%BC%80%E5%8F%91%E7%AF%87/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%B8%B8%E6%88%8FAI/%E8%A1%8C%E4%B8%BA%E6%A0%91.html">行为树</a></li>
</ul>
</li>
</ul>
<h2 id="参考资料"><a class="header" href="#参考资料">参考资料</a></h2>
<h3 id="参考书籍"><a class="header" href="#参考书籍">参考书籍</a></h3>
<ul>
<li><strong>《游戏编程算法与技巧》</strong>：人工智能章节介绍了A*、贪婪、Dijkstra等算法，导航网格，状态机。</li>
<li><a href="http://www.gameaipro.com/">《Game AI Pro》</a> ：专业AI文档的收集，想法、思路，网络版：<a href="http://www.gameaipro.com/">http://www.gameaipro.com/</a>。</li>
</ul>
<h3 id="开源项目"><a class="header" href="#开源项目">开源项目</a></h3>
<ul>
<li><a href="https://github.com/libgdx/libgdx">libgdx</a> ：Java 游戏开发框架</li>
<li><a href="https://github.com/libgdx/gdx-ai">gdx-ai</a> ：libGDX 的AI框架</li>
<li><a href="https://github.com/jsjolund/GdxDemo3D">GdxDemo3D</a> ：libGDX和gda-ai开发的寻路和AI示例。</li>
<li><a href="https://github.com/recastnavigation/recastnavigation">recastnavigation</a> ：Recast导入关卡几何体产出导航网格，Detour在导航网格上进行路径查询。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="寻路系统"><a class="header" href="#寻路系统">寻路系统</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a算法"><a class="header" href="#a算法">A*算法</a></h1>
<p>参考书籍《游戏编程算法与技巧》人工智能篇，参考开源项目libgdx,libgdx-ai,libgdx-ai-demo</p>
<h4 id="todo"><a class="header" href="#todo">TODO</a></h4>
<ul>
<li>libgdx-ai</li>
<li>原理</li>
<li>添加开源项目路径索引</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="navmesh网格"><a class="header" href="#navmesh网格">NavMesh网格</a></h1>
<h4 id="todo-1"><a class="header" href="#todo-1">TODO</a></h4>
<ul>
<li>四叉树</li>
<li>Unity导出NavMesh</li>
<li>UnityNavMesh的问题</li>
<li>数据组织方式</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="服务器寻路图形工具"><a class="header" href="#服务器寻路图形工具">服务器寻路图形工具</a></h1>
<h4 id=""><a class="header" href="#"></a></h4>
<ul>
<li>Java 2d图形显示工具</li>
<li>libgdx 3d 图形显示工具</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="游戏ai"><a class="header" href="#游戏ai">游戏AI</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="状态机"><a class="header" href="#状态机">状态机</a></h1>
<h4 id="todo-2"><a class="header" href="#todo-2">TODO</a></h4>
<ul>
<li>原理</li>
<li>优缺点，考虑因素</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="行为树"><a class="header" href="#行为树">行为树</a></h1>
<h4 id="todo-3"><a class="header" href="#todo-3">TODO</a></h4>
<ul>
<li>脚本对行为树的组装</li>
<li>xml行为树配置</li>
<li>节点类型介绍</li>
<li>原理</li>
<li>优缺点，考虑因素</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="excel导表"><a class="header" href="#excel导表">Excel导表</a></h1>
<h4 id="todo-4"><a class="header" href="#todo-4">TODO</a></h4>
<ul>
<li>MongoDB excel导表技术实现，规范</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="压力测试-2"><a class="header" href="#压力测试-2">压力测试</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http压测"><a class="header" href="#http压测">Http压测</a></h1>
<h4 id="todo-5"><a class="header" href="#todo-5">TODO</a></h4>
<ul>
<li>Locust 实现压测</li>
<li>Locust+Docker 搭建压测集群</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tcp压测"><a class="header" href="#tcp压测">Tcp压测</a></h1>
<h4 id="todo-6"><a class="header" href="#todo-6">TODO</a></h4>
<ul>
<li>压测集群架构图，实现原理</li>
<li>统计信息类型，</li>
<li>Unity工具开发使用的技术，原理，lua过滤器</li>
<li>Docker部署搭建压测集群</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux"><a class="header" href="#linux">Linux</a></h1>
<p>  本章节主要记录基于CentosOS 7常用指令；
开发和生产环境中Linux的常用软件安装维护；
生产环境中网络，防火墙，时间等的环境调优配置。
三个小节如下：</p>
<ul>
<li><a href="%E8%BF%90%E7%BB%B4%E7%AF%87/Linux/CentOS%E5%91%BD%E4%BB%A4%E5%8F%82%E8%80%83.html">CentOS命令参考</a></li>
<li><a href="%E8%BF%90%E7%BB%B4%E7%AF%87/Linux/CentOS%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85.html">CentOS软件安装</a></li>
<li><a href="%E8%BF%90%E7%BB%B4%E7%AF%87/Linux/CentOS%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html">CentOS环境配置</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="centos命令参考"><a class="header" href="#centos命令参考">CentOS命令参考</a></h1>
<p>  主要记录常用的系统命令使用及CentOS7中的安装使用。</p>
<h2 id="系统资源"><a class="header" href="#系统资源">系统资源</a></h2>
<p>  磁盘、CPU、内存、IO等常见命令使用。
游戏服务器程序可能出现死循环，定时器泄露等占用CPU；未正常释放对象占用过多的内存或者内存一直飙升等问题；
存储数据，网路请求太多，消耗IO过高等问题；日志输出太多，没有正常删除照成磁盘占满等问题。</p>
<h3 id="top命令"><a class="header" href="#top命令">top命令</a></h3>
<p>  top命令经常用来监控linux的系统状况，常用的性能分析工具，能够实时显示系统中各个进程的各种资源占用情况。
<a href="https://blog.csdn.net/yjclsx/article/details/81508455">参考地址</a> ：<a href="https://blog.csdn.net/yjclsx/article/details/81508455">https://blog.csdn.net/yjclsx/article/details/81508455</a>。进入top界面安如下安静可安需求显示。</p>
<ul>
<li>1：展开每个CPU的信息</li>
<li>P：以CPU的使用资源排序显示 </li>
<li>M：以内存的使用资源排序显示 </li>
<li>N：以pid排序显示 </li>
<li>T：由进程使用的时间累计排序显示</li>
</ul>
<pre><code class="language-shell script"># 1.查看指定进程 内存，cpu等信息
top -p 2913

# 2.查看进程详细信息，具体条目说明参考 https://blog.csdn.net/weixin_40584007/article/details/88847745  
cat /proc/1308/status
</code></pre>
<h3 id="dstat命令"><a class="header" href="#dstat命令">dstat命令</a></h3>
<p>  多功能系统资源统计生成工具 ( versatile tool for generating system resource statistics), 
可提供包含 <code>top、free、iostat、ifstat、vmstat</code>等多个工具的功能。详细使用可参考:<a href="https://www.cnblogs.com/shoufeng/p/9739805.html">https://www.cnblogs.com/shoufeng/p/9739805.html</a></p>
<pre><code class="language-shell script"># 1.安装
yum -y install dstat

# 2.查看
dstat
</code></pre>
<h3 id="iostat"><a class="header" href="#iostat">iostat</a></h3>
<p>  统计CPU和IO信息，详细使用可参考：<a href="https://www.cnblogs.com/architectforest/p/12628399.html">https://www.cnblogs.com/architectforest/p/12628399.html</a></p>
<pre><code class="language-shell script"># 1.查看
iostat -xmt 1
</code></pre>
<h3 id="ps命令"><a class="header" href="#ps命令">ps命令</a></h3>
<p>  查看具体进程相关信。</p>
<pre><code class="language-shell script"># 1.查询进程id
ps -ef | grep game-hall | awk '{print &quot;kill &quot;$2}'
</code></pre>
<h2 id="文件操作"><a class="header" href="#文件操作">文件操作</a></h2>
<p>  常用地文件上传，下载，打包，日志查看操作等。游戏服务器出现bug，有时候为了方便查看日志，需要将大的日志文件进行压缩打包，然后下载到本地进行操作。</p>
<h3 id="resz上传下载命令"><a class="header" href="#resz上传下载命令">re|sz上传下载命令</a></h3>
<p>  可在Xshell中快速上传，下载文件。</p>
<pre><code class="language-shell script"># 1.安装
yum -y install lrzsz

# 2.上传
rz

# 3.下载
sz [文件名]
</code></pre>
<h3 id="tar解压缩"><a class="header" href="#tar解压缩">tar解压缩</a></h3>
<pre><code class="language-shell script"># 1.打包压缩目录
tar -czvf game_hall_20201209.tar.gz game_hall_20201209121360/
</code></pre>
<h3 id="目录文件操作"><a class="header" href="#目录文件操作">目录文件操作</a></h3>
<pre><code class="language-shell script"># 1.删除backups目录30天之前修改的文件
find backups/ -mtime +30 -delete
</code></pre>
<h3 id="系统日志"><a class="header" href="#系统日志">系统日志</a></h3>
<p>  系统日志文件含义：</p>
<ul>
<li><code>/var/log/message</code> 系统启动后的信息和错误日志，是Red Hat Linux中最常用的日志之一</li>
<li><code>/var/log/secure</code> 与安全相关的日志信息</li>
<li><code>/var/log/maillog</code> 与邮件相关的日志信息</li>
<li><code>/var/log/cron</code> 与定时任务相关的日志信息</li>
<li><code>/var/log/spooler</code> 与UUCP和news设备相关的日志信息</li>
<li><code>/var/log/boot.log</code> 守护进程启动和停止相关的日志消息</li>
</ul>
<pre><code class="language-shell script"># 1.显示所有日志：
journalctl

# 2.查看最后10条日志
journalctl -n 10

# 3.跟踪日志：
journalctl -f

# 4只显示冲突、告警和错误
journalctl -p err..alert
</code></pre>
<h2 id="网络操作"><a class="header" href="#网络操作">网络操作</a></h2>
<p>  新服务器部署过程中需要查看两台服务器直接网络是否联通需要用<code>ping</code>命令；
检测网络端口是否开放，能否访问通需要使用<code>telent</code>命令；
在主机上下载安装包通常需要<code>wget</code>命令；
经常需要调用http请求进行后台管理操作需要使用<code>curl</code>命令。</p>
<h3 id="telnet"><a class="header" href="#telnet">Telnet</a></h3>
<pre><code class="language-shell script"># 1.检查是否安装
rpm -qa | grep telnet

# 2.查看yum列表
yum list | grep telnet

# 3.安装
yum install -y telnet-server.x86_64
yum install -y telnet.x86_64

# 4.执行
telnet 192.168.1.11 80
</code></pre>
<h3 id="wget"><a class="header" href="#wget">wget</a></h3>
<pre><code class="language-shell script"># 1.安装
yum -y install wget
</code></pre>
<h3 id="curl"><a class="header" href="#curl">curl</a></h3>
<pre><code class="language-shell script"># 1.安装
yum -y install curl
</code></pre>
<h3 id="16-wireshark"><a class="header" href="#16-wireshark">16. wireshark</a></h3>
<p>  监听服务器、客户端指定端口是否收到远端的消息包。用于网络消息包的分析。官方文档：<a href="https://www.wireshark.org/docs/wsug_html_chunked/index.html">https://www.wireshark.org/docs/wsug_html_chunked/index.html</a></p>
<pre><code class="language-shell script"># 1.安装
yum install wireshark wireshark-qt

# 2.服务器获取网络包
# 2.1.创建文件&amp;添加权限
touch packet.txt
chmod o+x packet.txt

# 2.2.查看网络接口
tshark -D

# 2.3.记录
tshark -w packet.txt -i eth0 -q

# 2.4.控制台查看指定端口(非常消耗内存)
tshark -i eth0 -Y &quot;tcp.port == 4019&quot;
tshark -i ens5 -Y &quot;tcp.port == 7050&quot;
</code></pre>
<h3 id="firewall-cmd"><a class="header" href="#firewall-cmd">firewall-cmd</a></h3>
<pre><code class="language-shell script"># 1.查看防火墙所有开放的端口
firewall-cmd --zone=public --list-ports
firewall-cmd --list-all
  
# 2.开放端口
firewall-cmd --zone=public --add-port=27017/tcp --permanent

# 3.生效
firewall-cmd --reload

# 4.防火墙开关，状态查看
systemctl stop firewalld
systemctl start firewalld
systemctl status firewalld
</code></pre>
<h3 id="netstat"><a class="header" href="#netstat">netstat</a></h3>
<p>  压测时可使用该命令查看网络连接是否正常创建，释放。</p>
<pre><code class="language-shell script">
# 1.查看端口
netstat -lnpt
 
# 2.查看指定端口
netstat -lnpt |grep 5672

# 3.网络状态统计信息
netstat -an | awk '/^tcp/ {++y[$NF]} END {for(w in y) print w, y[w]}'

# 4.连接数
netstat -an |grep ESTABLISHED |wc -l

# 5.每个ip连接数
netstat -nat|grep &quot;tcp&quot;|awk ' {print$5}'|awk -F : '{print$1}'|sort|uniq -c|sort -rn

# 6.每个ip ESTABLISHED连接数
netstat -nat|grep ESTABLISHED|awk '{print$5}'|awk -F : '{print$1}'|sort|uniq -c|sort -rn

# 7.查看指定端口的连接信息
netstat -an | grep 7050
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="centos软件安装"><a class="header" href="#centos软件安装">CentOS软件安装</a></h1>
<p>  一些常用软件安装，配置。</p>
<h3 id="jdk安装"><a class="header" href="#jdk安装">JDK安装</a></h3>
<p>  JDK安装可参考下面连接，生产环境使用docker运行程序，因此可跳过安装JDK。</p>
<ul>
<li><a href="https://www.cnblogs.com/wandoupeas/p/centos_jdk_install.html">JDK8</a>：<a href="https://www.cnblogs.com/wandoupeas/p/centos_jdk_install.html">https://www.cnblogs.com/wandoupeas/p/centos_jdk_install.html</a></li>
<li><a href="https://www.cnblogs.com/biem/p/13307438.html">JDK11</a>：<a href="https://www.cnblogs.com/biem/p/13307438.html">https://www.cnblogs.com/biem/p/13307438.html</a></li>
</ul>
<h3 id="vim安装"><a class="header" href="#vim安装">vim安装</a></h3>
<pre><code class="language-shell script"># 1.安装
yum -y install vim*
</code></pre>
<h3 id="tree安装"><a class="header" href="#tree安装">tree安装</a></h3>
<p>  展示目录的树形结构。</p>
<pre><code class="language-shell script"># 1.安装
yum install tree -y

# 2.展示目录
tree /data/game
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="centos环境配置"><a class="header" href="#centos环境配置">CentOS环境配置</a></h1>
<p>  本节主机介绍生产环境中linux内核调优，网络连接设置；时间设置，服务器部署在国外，还需要考虑时区的配置。</p>
<h3 id="网络连接数限制设置"><a class="header" href="#网络连接数限制设置">网络连接数限制设置</a></h3>
<h4 id="ulimit--n"><a class="header" href="#ulimit--n">ulimit -n</a></h4>
<p>参考文档：<a href="https://blog.csdn.net/hunhun1122/article/details/79391147">https://blog.csdn.net/hunhun1122/article/details/79391147</a></p>
<pre><code class="language-shell script"># 1.修改连接数，重启后生效
vim /etc/security/limits.conf
    * soft nofile 204800
    * hard nofile 204800
    * soft nproc 204800
    * hard nproc 204800
# 2.分别新建下面两个文件，并加入 如下内容
vim /etc/security/limits.d/90-nproc.conf 
    * soft nproc 204800  
    * hard nproc 204800  
vim /etc/security/limits.d/def.conf
    * soft nofile 204800  
    * hard nofile 204800  
 
# 3.临时设置连接数
ulimit -n 204800
</code></pre>
<h4 id="netcoresomaxconn"><a class="header" href="#netcoresomaxconn">net.core.somaxconn</a></h4>
<p>参考文档：<a href="https://www.cnblogs.com/my-show-time/p/15206020.html">https://www.cnblogs.com/my-show-time/p/15206020.html</a></p>
<pre><code class="language-shell script"># 1.查看参数
sysctl -a | grep net.core.somaxconn
# 2.设置 ，在末尾添加
vim /etc/sysctl.conf
    net.core.somaxconn=32768
sysctl -p
# 3.查看
sysctl -a | grep net.core.somaxconn
</code></pre>
<h3 id="网络超时设置"><a class="header" href="#网络超时设置">网络超时设置</a></h3>
<p>参考文档：<a href="https://docs.mongodb.com/v3.6/faq/diagnostics/#adjusting-the-tcp-keepalive-value">https://docs.mongodb.com/v3.6/faq/diagnostics/#adjusting-the-tcp-keepalive-value</a></p>
<pre><code class="language-shell script"># 1.使网络超时设置10分钟，超时后检测3次，每次30秒
vim /etc/sysctl.conf
    net.ipv4.tcp_keepalive_time=600
    net.ipv4.tcp_keepalive_intvl=30
    net.ipv4.tcp_keepalive_probes=3
sysctl -p
sysctl -a | grep keepalive
</code></pre>
<h3 id="常用网络设置"><a class="header" href="#常用网络设置">常用网络设置</a></h3>
<p>参考文档：<a href="https://help.aliyun.com/document_detail/41334.html">https://help.aliyun.com/document_detail/41334.html</a></p>
<pre><code class="language-shell script">#表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，
net.ipv4.tcp_keepalive_time=600
net.ipv4.tcp_keepalive_intvl=30
net.ipv4.tcp_keepalive_probes=3

#web应用中listen函数的backlog默认会给我们内核参数的net.core.somaxconn限制到128，而nginx定义的NGX_LISTEN_BACKLOG默认为511，所以有必要调整这个值
net.core.somaxconn=32688

#表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭  
net.ipv4.tcp_syncookies = 1  

#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭  
net.ipv4.tcp_tw_reuse = 1  

#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭  
net.ipv4.tcp_tw_recycle = 1

#表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间  
net.ipv4.tcp_fin_timeout=30

#表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。
net.ipv4.tcp_max_syn_backlog = 8192

#表示系统同时保持TIME_WAIT套接字的最大数量，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息。
#默认为180000，改为5000。对于Apache、Nginx等服务器，上几行的参数可以很好地减少TIME_WAIT套接字数量，但是对于 Squid，效果却不大。此项参数可以控制TIME_WAIT套接字的最大数量，避免Squid服务器被大量的TIME_WAIT套接字拖死。
net.ipv4.tcp_max_tw_buckets = 5000

#对外连接端口范围
net.ipv4.ip_local_port_range = 10240 65000
##表示文件句柄的最大数量
fs.file-max = 102400

# 多网卡防止丢包
net.ipv4.conf.all.rp_filter = 0
net.ipv4.conf.default.rp_filter = 0
</code></pre>
<hr />
<h3 id="日期时间设置"><a class="header" href="#日期时间设置">日期时间设置</a></h3>
<p>  服务器部署在国外，使用美国时间会有夏时令问题；之前服务器未同步网络时间，会存在系统时间运行一段时间跑块，导致多台主机时间不一致。因此采用如下配置：</p>
<pre><code class="language-shell script"># 1.查看系统时间
timedatectl status
date

# 2.查看可用时区
timedatectl list-timezones

# 3.设置时区
timedatectl set-timezone America/New_York

# 4.设置时间同步
timedatectl set-ntp yes

# 5.设置硬件时钟为UTC时间
timedatectl set-local-rtc 0

# 6.设置系统读取GST时区，美国纽约涉及到夏时令，会存在时间调快和调慢1小时问题
vi /etc/profile
    export TZ='GST+5'
source /etc/profile
</code></pre>
<p>参考文档：<a href="https://www.cnblogs.com/lei0213/p/8723106.html">https://www.cnblogs.com/lei0213/p/8723106.html</a> </p>
<h3 id="主机名称设置"><a class="header" href="#主机名称设置">主机名称设置</a></h3>
<pre><code class="language-shell script"># 1.查看主机名
uname -n

# 2.修改主机名
hostnamectl set-hostname cd-linux-34
hostnamectl set-hostname audit
</code></pre>
<h3 id="主机登录提示设置"><a class="header" href="#主机登录提示设置">主机登录提示设置</a></h3>
<pre><code class="language-shell script"># 1.登录linux提示主机功能
echo &quot;正式服Gate、Login、Hall服务器...&quot; &gt;/etc/motd
</code></pre>
<h3 id="磁盘挂载"><a class="header" href="#磁盘挂载">磁盘挂载</a></h3>
<p>  下面是测试服磁盘空间不足，单独给jenkins挂载一个磁盘。</p>
<pre><code class="language-shell script"># 1.查看磁盘
df -kh
fdisk -l

# 2.创建挂载目录
cd /mnt/
mkdir jenkins

# 3.挂载，及开机自动挂载
mount /dev/vdb1 /mnt/jenkins/
echo '/dev/vdb1 /mnt/jenkins ext4 defaults 0 0' &gt;&gt; /etc/fstab

# 4.关闭jenkins 移动目录到新位置
mv /var/lib/jenkins/ /mnt/jenkins/

# 5.创建软连接，重启jenkins
ln -s /mnt/jenkins/jenkins /var/lib
service jenkins start
</code></pre>
<h3 id="用户创建及权限设置"><a class="header" href="#用户创建及权限设置">用户创建及权限设置</a></h3>
<p>参考文档：<a href="https://blog.51cto.com/u_14557673/2446952">https://blog.51cto.com/u_14557673/2446952</a></p>
<pre><code class="language-shell script"># 1.创建账号
useradd -M develop
# 2.修改密码
passwd develop
    123456
    123456
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="开发工具"><a class="header" href="#开发工具">开发工具</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git"><a class="header" href="#git">Git</a></h1>
<h3 id="安装"><a class="header" href="#安装">安装</a></h3>
<pre><code class="language-shell script"># 1.安装
yum install -y git

# 2.查看版本
git version
</code></pre>
<h3 id="命令"><a class="header" href="#命令">命令</a></h3>
<pre><code class="language-shell script">
# 1.添加全部&amp;目录
git add .
git add Assets/Scripts

# 2.提交 
git commit -m &quot;初始化提交&quot;

# 3.推送
git push -u origin develop 

# 4.取消提交
git reset @~
</code></pre>
<h2 id="常见问题"><a class="header" href="#常见问题">常见问题</a></h2>
<h3 id="1git-push-remote-fatal-pack-exceeds-maximum-allowed-size"><a class="header" href="#1git-push-remote-fatal-pack-exceeds-maximum-allowed-size">1.Git Push remote: fatal: pack exceeds maximum allowed size</a></h3>
<ul>
<li>取消提交 <code>git reset @~</code>,提交少量文件，再推送</li>
<li>如果使用gitlab，可以到管理后台修改最大推送文件限制</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gitlab"><a class="header" href="#gitlab">Gitlab</a></h1>
<p>   Gitlab是开源的仓库管理系统，在Git基础上添加了Web服务，类似Github，使用非常方便，因此公司内部自行搭建了Gitlab。</p>
<h3 id="gitlab命令"><a class="header" href="#gitlab命令">gitlab命令</a></h3>
<p>参考文档：<a href="https://docs.gitlab.com/ee/administration/raketasks/maintenance.html#check-gitlab-configuration">https://docs.gitlab.com/ee/administration/raketasks/maintenance.html#check-gitlab-configuration</a></p>
<pre><code class="language-shell script"># 1.查看系统信息和gitlab信息
sudo gitlab-rake gitlab:env:info

# 2.检查配置
sudo gitlab-rake gitlab:check

# 3.数据迁移检测
sudo gitlab-rake db:migrate:status
</code></pre>
<h3 id="gitlab升级"><a class="header" href="#gitlab升级">gitlab升级</a></h3>
<p>参考文档：<br />
<a href="https://docs.gitlab.com/ee/update/plan_your_upgrade.html">https://docs.gitlab.com/ee/update/plan_your_upgrade.html</a>
<a href="https://docs.gitlab.com/ee/update/package/">https://docs.gitlab.com/ee/update/package/</a><br />
<a href="https://docs.gitlab.com/ee/update/index.html#upgrade-paths">https://docs.gitlab.com/ee/update/index.html#upgrade-paths</a></p>
<pre><code class="language-shell script"># 1.查看可用版本包
yum --showduplicates list gitlab-ee

# 2.更新到指定版本，gitlab必须一步一步的更新到最新版本，中间版本不能跳过
yum install gitlab-ee-13.8.8-ee.0.el7
yum install gitlab-ee-13.12.15-ee.0.el7
yum install gitlab-ee-14.0.12-ee.0.el7
yum install gitlab-ee-14.6.2-ee.0.el7
</code></pre>
<p>升级错误问题：<br />
安装官方路径 yum install gitlab-ee-14.0.12-ee.0.el7 升级到 yum install gitlab-ee-14.6.2-ee.0.el7 报错<br />
参考文档：<a href="https://docs.gitlab.com/ee/user/admin_area/monitoring/background_migrations.html#database-migrations-failing-because-of-batched-background-migration-not-finished">https://docs.gitlab.com/ee/user/admin_area/monitoring/background_migrations.html#database-migrations-failing-because-of-batched-background-migration-not-finished</a></p>
<pre><code class="language-shell script"># 1.重新加载配置
sudo gitlab-ctl reconfigure

# 2.重新迁移数据库
sudo gitlab-rake db:migrate
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="maven"><a class="header" href="#maven">Maven</a></h1>
<h3 id="maven安装"><a class="header" href="#maven安装">Maven安装</a></h3>
<p>参考文档：<a href="https://blog.csdn.net/djrm11/article/details/106340433">https://blog.csdn.net/djrm11/article/details/106340433</a><br />
setting配置 <a href="%E8%BF%90%E7%BB%B4%E7%AF%87/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/settings.xml">setting.xml</a></p>
<pre><code class="language-shell script"># 1.官网下注包上传到 data目录
tar -xzvf apache-maven-3.6.3-bin.tar.gz
  
# 2.设置环境变量，在profile末尾添加
vi /etc/profile
    MAVEN_HOME=/data/apache-maven-3.6.3
    export PATH=${MAVEN_HOME}/bin:${PATH}
source /etc/profile

# 3.设置jdk版本
cd /data/apache-maven-3.6.3/bin
vim mvn
    JAVA_HOME=/data/java/jdk-14.0.2
    
# 4.修改setting配置
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nexus"><a class="header" href="#nexus">Nexus</a></h1>
<p>Nexus 搭建公司内部maven私有仓库，便于公司内部包的版本管理，加速获取公共包。</p>
<h3 id="nexus3-安装"><a class="header" href="#nexus3-安装">Nexus3 安装</a></h3>
<p>参考文档：<a href="https://hub.docker.com/r/sonatype/nexus3/#notes">https://hub.docker.com/r/sonatype/nexus3/#notes</a></p>
<pre><code class="language-shell script"># 1.创建挂载目录
mkdir /data/nexus-data

# 2.运行镜像
docker run -d -p 8081:8081 --name nexus -v /data/nexus-data:/nexus-data sonatype/nexus3
</code></pre>
<h3 id="常见问题-1"><a class="header" href="#常见问题-1">常见问题</a></h3>
<h4 id="私有仓库上传snapshot-jar包项目检出snapshot-jar类文件找不到问题"><a class="header" href="#私有仓库上传snapshot-jar包项目检出snapshot-jar类文件找不到问题">私有仓库上传snapshot jar包，项目检出snapshot jar类文件找不到问题</a></h4>
<p>参考文档：<a href="https://segmentfault.com/a/1190000022068814">https://segmentfault.com/a/1190000022068814</a></p>
<ol>
<li>配置pom.xml 拉取最新jar包</li>
</ol>
<pre><code class="language-xml">&lt;repositories&gt;
    &lt;repository&gt;
        &lt;id&gt;public&lt;/id&gt;
        &lt;url&gt;http://192.168.0.1:8081/repository/maven-public/&lt;/url&gt;
        &lt;snapshots&gt;
            &lt;!-- 始终下载最新的 snapshot 包 ，因为协议消息在其他项目，时刻改变 --&gt;
            &lt;updatePolicy&gt;always&lt;/updatePolicy&gt;
        &lt;/snapshots&gt;
    &lt;/repository&gt;
&lt;/repositories&gt;

</code></pre>
<ol start="2">
<li>jar 包运行，pom.xml设置项目打包插件</li>
</ol>
<pre><code class="language-xml">&lt;plugin&gt;
 &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
 &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
 &lt;version&gt;3.2.0&lt;/version&gt;
 &lt;configuration&gt;
     &lt;archive&gt;
         &lt;manifest&gt;
             &lt;addClasspath&gt;true&lt;/addClasspath&gt;
             &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt;
             &lt;mainClass&gt;com.game.gate.GateApp&lt;/mainClass&gt;
             &lt;!--配置可使用快照版本--&gt;
             &lt;useUniqueVersions&gt;false&lt;/useUniqueVersions&gt;
         &lt;/manifest&gt;
     &lt;/archive&gt;
 &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>
<h3 id="maven-settingxml-镜像配置错误导致拉取不到存在的jar包问题"><a class="header" href="#maven-settingxml-镜像配置错误导致拉取不到存在的jar包问题">maven setting.xml 镜像配置错误导致拉取不到存在的jar包问题</a></h3>
<p>参考文档： https://segmentfault.com/q/1010000019941502/a-1020000019941560</p>
<pre><code class="language-xml"> &lt;mirror&gt;
        &lt;id&gt;public&lt;/id&gt;
        &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;
        &lt;name&gt;central repository&lt;/name&gt;
        &lt;url&gt;http://192.168.0.1:80/repository/maven-public/&lt;/url&gt;
    &lt;/mirror&gt; 
</code></pre>
<p>mirrorOf 最开始配置问<code>central</code>，导致上传到snapshot库中的jar包无法下载，改为<code>*</code>问题解决</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nps"><a class="header" href="#nps">Nps</a></h1>
<p>  Nps内网穿透工具，可以实现外网连接公司电脑进行办公，特别是疫情期间居家办公和线上问题处理。</p>
<h2 id="搭建"><a class="header" href="#搭建">搭建</a></h2>
<p>参考文档：<br />
<a href="https://blog.csdn.net/qq_41225906/article/details/125888457">https://blog.csdn.net/qq_41225906/article/details/125888457</a><br />
<a href="https://ehang-io.github.io/nps/#/">https://ehang-io.github.io/nps/#/</a></p>
<pre><code class="language-shell script"># 1.服务器搭建
# 1.1 下载
cd /data
mkdir nps
cd nps
wget https://github.com/ehang-io/nps/releases/download/v0.26.10/linux_amd64_server.tar.gz
tar -xzvf linux_amd64_server.tar.gz
# 1.2安装，启动，关闭
./nps install
nps start
nps stop

# 2.进入网页后台进行配置，创建用户，TCP隧道

# 3.Windows 连接服务器
npc.exe -server=127.0.0.1:8024 -vkey=7fx8smcst1cp0rw3 -type=tcp
# 3.1注册服务，运行，停止
npc.exe install -server=127.0.0.1:8024 -vkey=7fx8smcst1cp0rw3 -type=tcp
npc.exe start
npc.exe stop

# 4.远程连接地址
mstsc
127.0.0.1:8888     
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="项目部署"><a class="header" href="#项目部署">项目部署</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docker"><a class="header" href="#docker">Docker</a></h1>
<p>  因为slots类游戏有上百个子游戏，每个子游戏都是单独的服务，如果使用传统的服务器部署一整套或更新将是恶魔般的存在，因此用docker搭建了一套自动化部署流程。</p>
<h2 id="部署流程"><a class="header" href="#部署流程">部署流程</a></h2>
<p>TODO 画流程图，结合jenkins</p>
<h2 id="环境搭建"><a class="header" href="#环境搭建">环境搭建</a></h2>
<h3 id="linux环境搭建"><a class="header" href="#linux环境搭建">Linux环境搭建</a></h3>
<h4 id="安装-1"><a class="header" href="#安装-1">安装</a></h4>
<p>安装参考：<a href="https://www.linuxprobe.com/install-use-docker-in-centos7.html">https://www.linuxprobe.com/install-use-docker-in-centos7.html</a></p>
<pre><code class="language-shell script"># 1.安装
yum install docker

# 2.查看版本号
docker version

# 3.启动
systemctl  start docker.service

# 4.开机启动
systemctl  enable docker.service
</code></pre>
<h4 id="私有仓库安装"><a class="header" href="#私有仓库安装">私有仓库安装</a></h4>
<p>参考文档：<br />
<a href="https://hub.docker.com/_/registry">https://hub.docker.com/_/registry</a><br />
<a href="https://docs.docker.com/registry/">https://docs.docker.com/registry/</a></p>
<pre><code class="language-shell script">docker run -d -p 5000:5000 --restart=always -v /data/registry:/var/lib/registry --name registry registry:2
</code></pre>
<h4 id="配置远程访问"><a class="header" href="#配置远程访问">配置远程访问</a></h4>
<pre><code class="language-shell script"># 1.配置远程访问 替换如下内容，记得开放2375端口的访问权限
vi /lib/systemd/system/docker.service
    ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock -H tcp://0.0.0.0:7654

# 2.配置docker参数，添加如下内容
vi /etc/docker/daemon.json
    {
        &quot;insecure-registries&quot;:[
            &quot;192.168.0.1:5000&quot;
        ],
        &quot;registry-mirrors&quot;:[
            &quot;https://6kx4zyno.mirror.aliyuncs.com&quot;
        ],
        &quot;log-driver&quot;:&quot;json-file&quot;,
        &quot;log-opts&quot;:{
            &quot;max-size&quot;:&quot;1000m&quot;,
            &quot;max-file&quot;:&quot;1&quot;
        }
    }
</code></pre>
<h4 id="错误处理"><a class="header" href="#错误处理">错误处理</a></h4>
<ul>
<li>exec: &quot;docker-proxy&quot;: executable file not found in $PATH<br />
参考文档:
<a href="https://www.cnblogs.com/cxbhakim/p/9149596.html">https://www.cnblogs.com/cxbhakim/p/9149596.html</a></li>
</ul>
<pre><code class="language-shell script">ln -s /usr/libexec/docker/docker-proxy-current /usr/bin/docker-proxy
ln -s /usr/libexec/docker/docker-proxy-current /usr/bin/docker-proxy
</code></pre>
<ul>
<li>Bind for 0.0.0.0:80 failed: port is already allocated.<br />
参考文档:<a href="https://www.maoyuanrun.com/2017/01/12/docker-port-is-already-allocated/">https://www.maoyuanrun.com/2017/01/12/docker-port-is-already-allocated/</a></li>
</ul>
<pre><code class="language-shell script">ps -aux | grep -v grep | grep docker-proxy
systemctl stop docker.service
docker rm $(docker ps -aq)
systemctl status docker.service
</code></pre>
<ul>
<li>error: docker-runc not installed on system<br />
参考文档：<a href="https://blog.51cto.com/michaelkang/2160171">https://blog.51cto.com/michaelkang/2160171</a></li>
</ul>
<pre><code class="language-shell script">cd /usr/libexec/docker/
sudo ln -s docker-runc-current docker-runc 
</code></pre>
<h3 id="windows-docker数据盘设置"><a class="header" href="#windows-docker数据盘设置">windows docker数据盘设置</a></h3>
<p>  docker 安装默认镜像目录在C盘中，使用一段时间后此文件特别大，然而电脑C盘空间太小，
因此需要将此文件移动到空间大的磁盘上。<br />
参考文档：<a href="https://blog.csdn.net/weixin_47513022/article/details/120083726">https://blog.csdn.net/weixin_47513022/article/details/120083726</a></p>
<h2 id="维护"><a class="header" href="#维护">维护</a></h2>
<h3 id="常用命令"><a class="header" href="#常用命令">常用命令</a></h3>
<pre><code class="language-shell script"># 1.进入容器
docker exec -it d1412927d331 /bin/sh
# 管理员进入才可编辑配置文件
docker exec -it --user root  a6882651c45b /bin/sh

# 2. 内存 cpu查看
docker stats
# 2.1 不显示名称处理方案
docker stats $(docker ps --format '{{.Names}}')

# 3.日志查看
docker logs -f 8da217c8723a

# 4.docker信息
docker info
docker container inspect 73a656d7fe44

# 5.网络
docker network ls
</code></pre>
<h3 id="磁盘清理"><a class="header" href="#磁盘清理">磁盘清理</a></h3>
<pre><code class="language-shell script"># 1.目录磁盘占用
du -h

# 2.统计当前目录大小
du -sh ./*
du -sh /data

# 3.系统磁盘
df -h

# 4.docker查看磁盘
docker system df

# 5.清理磁盘，删除关闭的容器、无用的数据卷和网络，以及dangling镜像
docker system prune

# 6.删除所有没使用的镜像
docker system prune -a
</code></pre>
<h3 id="线上问题"><a class="header" href="#线上问题">线上问题</a></h3>
<ul>
<li>
<p>failed to retrieve docker-init version
Mar 26 01:25:00 ip-172-31-62-192.us-west-2.compute.internal dockerd[1458]: 
time=&quot;2021-03-26T02:25:00.103411934-04:00&quot; level=warning msg=&quot;failed to retrieve docker-init version&quot;<br />
  官方解释版本太老，已经不维护， 版本1.13,正式服docker需要更新，现在是17年版本了</p>
</li>
<li>
<p>Cannot connect to the Docker daemon at tcp://0.0.0.0:2375. Is the docker daemon running
  因为阿里云服务器进行yum update 所有软件，导致docker版本更新到 1.41 （20.10.12）导致之前的配置失效，从新<code>配置远程访问</code></p>
</li>
<li>
<p>ERROR: ZONE_CONFLICT: 'docker0' already bound to a zone<br />
  因为阿里云服务器进行yum update 所有软件，导致docker版本更新到 1.41 （20.10.12）,更新防火墙设置。
参考文档：<a href="https://www.cnblogs.com/wxbn/p/15057806.html">https://www.cnblogs.com/wxbn/p/15057806.html</a></p>
</li>
</ul>
<pre><code class="language-shell script"> # 1.检查firewall-cmd中是否存在docker zone 
 firewall-cmd --get-active-zones
 
 # 2.如果“docker”区域可用，将接口更改为 docker0（非持久化）
 sudo firewall-cmd --zone=docker --change-interface=docker0
 
 # 3.如果“docker”区域可用，请将接口更改为 docker0（持久化）
 sudo firewall-cmd --permanent --zone=docker --change-interface=docker0 
 sudo systemctl restart firewalld
 
 # 4.启动docker 
 systemctl  start  docker
 
 # 5。查看
 systemctl status docker
</code></pre>
<h3 id="docker中查看-java堆栈信息"><a class="header" href="#docker中查看-java堆栈信息">docker中查看 java堆栈信息</a></h3>
<p>参考文档： http://t.zoukankan.com/duanxz-p-10238570.html</p>
<pre><code class="language-shell script"># 1.查看容器id
docker ps

# 2.进入docker
docker exec -it 26612c5d62a2 /bin/sh

# 3.查看java进程
jps

# 4.输出堆栈信息
jstack 1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jenkins"><a class="header" href="#jenkins">Jenkins</a></h1>
<h3 id="安装-2"><a class="header" href="#安装-2">安装</a></h3>
<p>参考文档：<br />
<a href="https://pkg.jenkins.io/redhat-stable/">https://pkg.jenkins.io/redhat-stable/</a><br />
<a href="https://www.jianshu.com/p/368685768680">https://www.jianshu.com/p/368685768680</a></p>
<pre><code class="language-shell script"># 1.安装
sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo
sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key

yum install jenkins
# 2.配置启动 
vi /etc/sysconfig/jenkins
   JENKINS_PORT=40015
   JENKINS_JAVA_OPTIONS=&quot;-server -Xms1024m -Xmx2048m -XX:PermSize=256m -XX:MaxPermSize=512m -Djava.awt.headless=true&quot;
chkconfig jenkins on
service jenkins start
</code></pre>
<ul>
<li>
<p>错误处理：AWT is not properly configured on this server
https://blog.csdn.net/qq_44959735/article/details/104363491</p>
</li>
<li>
<p>mvn 命令无法识别问题<br />
https://www.jianshu.com/p/993ffb82ee0e</p>
</li>
</ul>
<h3 id="windows-编码设置"><a class="header" href="#windows-编码设置">Windows 编码设置</a></h3>
<p>  进入 <code>E:\Program Files\Jenkins</code> 在jenkins.xml中设置启动参数 <code> -Dfile.encoding=UTF-8</code></p>
<p>TODO 结合docker进行流程介绍 </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据库"><a class="header" href="#数据库">数据库</a></h1>
<h3 id="todo-7"><a class="header" href="#todo-7">TODO</a></h3>
<ul>
<li>AWS DocumentDB</li>
<li>AWS MemoryDB</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mongodb"><a class="header" href="#mongodb">MongoDB</a></h1>
<h2 id="安装-3"><a class="header" href="#安装-3">安装</a></h2>
<h3 id="docker安装"><a class="header" href="#docker安装">Docker安装</a></h3>
<p>参考文档：<br />
<a href="https://www.runoob.com/docker/docker-install-mongodb.html">https://www.runoob.com/docker/docker-install-mongodb.html</a><br />
<a href="https://hub.docker.com/_/mongo?tab=description">https://hub.docker.com/_/mongo?tab=description</a></p>
<pre><code class="language-shell script"> # 1. 运行镜像
docker run -itd --name mongo-3.6.23 -p 27017:27017 mongo:3.6.23 --auth

# 2. 进入容器创建账号
$ docker exec -it mongo-3.6.23 mongo admin
# 创建一个名为 admin，密码为 123456 的用户。
db.createUser({ user:'admin',pwd:'123456',roles:[ { role:'userAdminAnyDatabase', db: 'admin'},&quot;readWriteAnyDatabase&quot;]});
# 尝试使用上面创建的用户信息进行连接。
db.auth('admin', '123456')

# 3. 连接地址
mongodb://admin:123456@192.168.0.1:27017/?authSource=admin&amp;readPreference=primary&amp;appname=MongoDB%20Compass&amp;ssl=false

</code></pre>
<h3 id="centos7-安装配置"><a class="header" href="#centos7-安装配置">CentOS7 安装&amp;配置</a></h3>
<p>参考文档：<br />
<a href="https://docs.mongodb.com/v3.6/tutorial/install-mongodb-on-red-hat/">https://docs.mongodb.com/v3.6/tutorial/install-mongodb-on-red-hat/</a></p>
<pre><code class="language-shell script"># 1.设置安装源
vim /etc/yum.repos.d/mongodb-org-3.6.repo
    [mongodb-org-3.6]
    name=MongoDB Repository
    baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.6/x86_64/
    gpgcheck=1
    enabled=1
    gpgkey=https://www.mongodb.org/static/pgp/server-3.6.asc

# 2.安装
sudo yum install -y mongodb-org

# 3.启动
sudo systemctl start mongod

# 4.开机启动
sudo systemctl enable mongod

# 5.关闭|重启
sudo systemctl stop mongod
sudo systemctl restart mongod

# 连接
mongo --host 127.0.0.1:27017
</code></pre>
<h4 id="配置-disable-transparent-huge-pages-thp"><a class="header" href="#配置-disable-transparent-huge-pages-thp">配置 Disable Transparent Huge Pages (THP)</a></h4>
<p>参考文档：<a href="https://docs.mongodb.com/v3.6/tutorial/transparent-huge-pages/">https://docs.mongodb.com/v3.6/tutorial/transparent-huge-pages/</a></p>
<h4 id="配置文件mongodconf"><a class="header" href="#配置文件mongodconf">配置文件<a href="%E8%BF%90%E7%BB%B4%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93/Mongo/mongod.conf">mongod.conf</a></a></h4>
<p>参考文档： <a href="https://docs.mongodb.com/v3.6/administration/configuration/">https://docs.mongodb.com/v3.6/administration/configuration/</a><br />
  外网访问和密码验证，文件路径<code>/etc/mongod.cnf</code>,添加修改如下内容：</p>
<pre><code class="language-shell script"># network interfaces
net:
  port: 27017
  bindIp: 0.0.0.0  # Listen to local interface only, comment to listen on all interfaces.
#security:
security:
  authorization: enabled
</code></pre>
<h4 id="连接数设置"><a class="header" href="#连接数设置">连接数设置</a></h4>
<p>官方推荐设置:<a href="https://docs.mongodb.com/v3.6/reference/ulimit/#recommended-ulimit-settings">https://docs.mongodb.com/v3.6/reference/ulimit/#recommended-ulimit-settings</a></p>
<pre><code class="language-shell script">-f (file size): unlimited
-t (cpu time): unlimited
-v (virtual memory): unlimited [1]
-l (locked-in-memory size): unlimited
-n (open files): 64000
-m (memory size): unlimited [1] [2]
-u (processes/threads): 64000
</code></pre>
<h4 id="每日备份"><a class="header" href="#每日备份"><a href="%E8%BF%90%E7%BB%B4%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93/Mongo/backup.sh">每日备份</a></a></h4>
<p>参考文档：<a href="https://www.jb51.net/article/135847.htm">https://www.jb51.net/article/135847.htm</a></p>
<pre><code class="language-shell script"># 1.创建存储目录
cd /data
mkdir mongo
mkdir backup
mkdir backup/now
mkdir backup/list

# 2.编辑脚本
vim backup.sh
    #!/bin/sh
    OUT_DIR=/data/mongo/backup/now #临时备份目录
    TAR_DIR=/data/mongo/backup/list #备份存放路径
    DATE=`date +%Y_%m_%d` #获取当前系统时间
    DB_USER=root #数据库账号
    DB_PASS=123456 #数据库密码
    DAYS=7 #DAYS=7代表删除7天前的备份，即只保留最近7天的备份
    TAR_BAK=&quot;mongo_backup_$DATE.tar.gz&quot; #最终保存的数据库备份文件名
    cd $OUT_DIR
    rm -rf $OUT_DIR/*
    mkdir -p $OUT_DIR/$DATE
    mongodump -u $DB_USER -p $DB_PASS -o $OUT_DIR/$DATE #备份全部数据库
    tar -zcvf $TAR_DIR/$TAR_BAK $OUT_DIR/$DATE #压缩为.tar.gz格式
    find $TAR_DIR/ -mtime +$DAYS -delete #删除7天前的备份文件

# 3.添加脚本执行权限
chmod +x backup.sh

# 4.添加定时任务,每天凌晨2点30进行备份
crontab -e
  30 2 * * * sh /data/mongo/backup.sh
crontab -l
</code></pre>
<h4 id="将备份数据复制到另外一台主机"><a class="header" href="#将备份数据复制到另外一台主机">将备份数据复制到另外一台主机</a></h4>
<p>参考文档：<a href="https://blog.csdn.net/gjwgjw1111/article/details/103515031">https://blog.csdn.net/gjwgjw1111/article/details/103515031</a> （有坑，不要在配置文件中加注释）<br />
数据库所在服务器1 每日定时将数据推送到服务器2</p>
<h5 id="备份主机2"><a class="header" href="#备份主机2">备份主机2</a></h5>
<pre><code class="language-shell script"># 1.查询rsync是否安装
rpm -qa rsync

# 2.创建备份目录
mkdir /data/mongo/backup
chown -R nobody:nobody /data/mongo/backup

# 3.编辑服务器配置文件，输入如下内容
vim /etc/rsyncd.conf
    #以下是全局配置
    log file = /var/log/rsyncd.log
    pid file = /var/run/rsyncd.pid
    lock file = /var/lock/rsyncd
    use chroot = yes
    read only = no
    [mongobackup]
       comment = sync rsync/data/mongo/backup
       path = /data/mongo/backup
       gid = root
       max connections = 10
       auth users = root
       secrets file = /etc/rsyncd.pass
       hosts allow = 172.31.49.33,127.0.0.1
       timeout = 600

# 4.创建认证文件，输入如下内容
vi /etc/rsyncd.pass
    root:123456
chmod 600 /etc/rsyncd.pass
vim /etc/xinetd.d/rsync
    service rsync
    {
            disable = no
            socket_type = stream
            wait = no
            user = root
            server = /usr/bin/rsync
            server_args = --daemon
            log_on_failure += USERID
    }

# 5.启动服务器 重启时记得删除rsyncd.pid：‘rm -rf /var/run/rsyncd.pid’
rsync --daemon --config=/etc/rsyncd.conf

# 6.开启端口，防火墙设置
sudo firewall-cmd --zone=public --add-port=873/tcp --permanent
</code></pre>
<h5 id="mongodb安装端"><a class="header" href="#mongodb安装端">mongodb安装端</a></h5>
<pre><code class="language-shell script"># 1.创建账号密码
vi /etc/rsync_client.pwd
    123456
chmod 600 /etc/rsync_client.pwd

# 2.同步目录测试
rsync -auvrtzopgP --progress --password-file=/etc/rsync_client.pwd /data/mongo/backup/list root@172.31.55.20::mongobackup

# 3.回到 每日备份 在backup.sh中添加如下代码
rsync -auvrtzopgP --progress --password-file=/etc/rsync_client.pwd $TAR_DIR/$TAR_BAK root@172.31.55.20::mongobackup

</code></pre>
<h4 id="自动删除备份数据"><a class="header" href="#自动删除备份数据">自动删除备份数据</a></h4>
<pre><code class="language-shell script"># 1.创建备份文件 redis、mongodb一样，只是路径不同
touch delete_backup.sh
chmod 754 delete_backup.sh
vim delete_backup.sh
    #!/bin/sh
    find /data/mongo/backup/ -mtime +30 -delete

# 2.删除30天前的备份文件pw
crontab -e
   30 2 * * * sh /data/mongo/delete_backup.sh
   35 2 * * * sh /data/redis/delete_backup.sh
crontab -l
</code></pre>
<h2 id="命令操作"><a class="header" href="#命令操作">命令操作</a></h2>
<h3 id="账号密码"><a class="header" href="#账号密码">账号密码</a></h3>
<p>参考文档：<br />
<a href="https://www.jianshu.com/p/d21cdf929a2e">https://www.jianshu.com/p/d21cdf929a2e</a><br />
<a href="https://docs.mongodb.com/v3.6/tutorial/enable-authentication/">https://docs.mongodb.com/v3.6/tutorial/enable-authentication/</a></p>
<pre><code class="language-shell script"># 1.创建管理员账号
use admin
db.createUser(
  {
    user: &quot;root&quot;,
    pwd: &quot;123456&quot;,
    roles: [
       { role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; }
    ]
  }
)

# 2.登录
db.auth('root','123456')
mongo -u root -p 123456


# 3.授权
 db.grantRolesToUser(
    &quot;root&quot;,
    [
        { role: &quot;root&quot;, db: &quot;admin&quot; },
    ]
)
db.grantRolesToUser(&quot;root&quot;,[{role:&quot;readWrite&quot;,db:&quot;common&quot;}])

# 4.读写权限账号
db.createUser(
  {
    user: &quot;admin&quot;,
    pwd: &quot;123456&quot;,
    roles: [
       { role: &quot;readWriteAnyDatabase&quot;, db: &quot;admin&quot; }
    ]
  }
)
db.auth('admin','123456')

# 5.查看权限账号
db.createUser(
  {
    user: &quot;read&quot;,
    pwd: &quot;123456&quot;,
    roles: [
       { role: &quot;readAnyDatabase&quot;, db: &quot;admin&quot; }
    ]
  }
)

# 6.数据库权限账号
db.createUser({user:&quot;hall&quot;,pwd:&quot;123456&quot;,roles:[{role:&quot;readWrite&quot;,db:&quot;game-hall&quot;}]})

# 7.删除用户
db.dropUser(&quot;slots&quot;)
</code></pre>
<h3 id="性能统计设置"><a class="header" href="#性能统计设置">性能统计设置</a></h3>
<p>参考文档：<a href="https://docs.mongodb.com/v3.6/tutorial/manage-the-database-profiler/#database-profiling-view-status">https://docs.mongodb.com/v3.6/tutorial/manage-the-database-profiler/#database-profiling-view-status</a></p>
<pre><code class="language-shell script">db.setProfilingLevel(1)
# 最近10条慢操作
db.system.profile.find().limit(10).sort( { ts : -1 } ).pretty()
</code></pre>
<h3 id="数据备份还原"><a class="header" href="#数据备份还原">数据备份还原</a></h3>
<p>参考文档：<br />
<a href="https://docs.mongodb.com/v3.6/tutorial/backup-and-restore-tools/">https://docs.mongodb.com/v3.6/tutorial/backup-and-restore-tools/</a><br />
<a href="https://www.cnblogs.com/clsn/p/8244206.html">https://www.cnblogs.com/clsn/p/8244206.html</a></p>
<pre><code class="language-shell script"># 1.备份
cd /data/mongo/backup
mkdir 2020****
cd 2020****
mongodump --username root --password 123456
#显示备份目录大小
du -h --max-depth=1 /data/mongo/backup/    

# 2.数据还原
mongorestore --host mongodb1.example.net --port 3017 --username user --password 'pass' /opt/backup/mongodump-2013-10-24
mongorestore -h 172.31.49.33:27017 -uroot -p123456 --authenticationDatabase admin -d game-hall -c club /data/mongo/backup/now/2022_01_07/game-hall/club.bson
</code></pre>
<h3 id="常用命令-1"><a class="header" href="#常用命令-1">常用命令</a></h3>
<pre><code class="language-shell script"># 1.查询 昵称包含指定字符串，显示指定字段
db.role.find({&quot;nick&quot;:{$regex:&quot;Helen&quot;}},{nick:1,rid:1,gold:1})
db.player.find({&quot;level&quot;:{&quot;$gte&quot;:50}},{_id:1,nick:1,level:1})

# 2.查询所有注册人数
db.getCollection('role').find({&quot;roleType&quot;:0}).count({})

# 3.查询平台充值总和
db.billing_order.aggregate([
   { $match: { status: 200 } },
   { $group: { _id: &quot;$platform&quot;, total: { $sum: &quot;$price&quot; } } }
])

# 4.查询总注册人数
db.role.aggregate([
   { $group: { _id: &quot;$roleType&quot;, count: { $sum: 1 } } }
])

# 5.查询最近时间段登录人数
db.role.aggregate([
   { $match: { lastLoginTime: {&quot;$gt&quot;:ISODate(&quot;2021-01-01T00:00:01.303Z&quot;)} } },
   { $group: { _id: &quot;$roleType&quot;, count: { $sum: 1 } } }
])
db.role.aggregate([
   { $match: { registerTime: {&quot;$lt&quot;:ISODate(&quot;2021-01-08T00:00:01.303Z&quot;),&quot;$gt&quot;:ISODate(&quot;2021-01-07T00:00:01.303Z&quot;)} } },
   { $group: { _id: &quot;$roleType&quot;, count: { $sum: 1 } } }
])

# 6.查询人数大于10的公会
db.club.aggregate([
    {$project:{memberCount:{$size:&quot;$memberIds&quot;}}},
    {$match:{memberCount: {$gte:10}}}
 ]).itcount()

# 7.模糊查询
{&quot;nick&quot;:{$regex:/^.*emp.*$/i}}

# 8.删除
db.config_board.deleteMany({&quot;type&quot;:2})

# 9.数组大小查询
{&quot;firstEnter&quot;:true,&quot;refreshTime&quot;:{&quot;$gt&quot;:1646024300450},&quot;pushCoin.levelEntries&quot;:{&quot;$exists&quot;:true},&quot;$where&quot;: &quot;this.pushCoin.levelEntries.length&gt;1&quot; }

# 10.查看可用连接
db.serverStatus().connections

# 11.查询性能分析
db.account.find({&quot;rid&quot;:1000037}).explain(&quot;executionStats&quot;)

# 12.创建索引
db.account.createIndex( { &quot;accountName&quot; : 1 } )
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="redis"><a class="header" href="#redis">Redis</a></h1>
<h2 id="安装-4"><a class="header" href="#安装-4">安装</a></h2>
<h3 id="docker安装-1"><a class="header" href="#docker安装-1">Docker安装</a></h3>
<p>参考文档： <a href="https://hub.docker.com/_/redis/?tab=description&amp;page=1&amp;ordering=last_updated">https://hub.docker.com/_/redis/?tab=description&amp;page=1&amp;ordering=last_updated</a></p>
<pre><code class="language-shell script"># 1. 创建挂载目录
cd data
mkdir redis

# 2. 拉取镜像并运行 
docker run --name redis-5.0.12 --restart=always -p 6379:6379 -v /data/redis:/data -d redis:5.0.12 redis-server --appendonly yes --requirepass 123456
</code></pre>
<h3 id="centos7安装"><a class="header" href="#centos7安装">CentOS7安装</a></h3>
<p>参考文档：<a href="https://www.cnblogs.com/heqiuyong/p/10463334.html">https://www.cnblogs.com/heqiuyong/p/10463334.html</a></p>
<ul>
<li>安装路径： <code>/usr/local/redis</code></li>
<li>配置|命令路径：<code>/usr/local/redis/bin</code></li>
<li>数据|日志路径：<code>/data/redis</code></li>
<li><a href="%E8%BF%90%E7%BB%B4%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/redis.conf">redis.conf</a> 修改内容</li>
</ul>
<h4 id="每日备份-1"><a class="header" href="#每日备份-1">每日备份</a></h4>
<p>参考文档：<a href="https://blog.csdn.net/Junetest/article/details/104796142/">https://blog.csdn.net/Junetest/article/details/104796142/</a></p>
<ul>
<li><a href="%E8%BF%90%E7%BB%B4%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/backup.sh">脚本地址</a>：<code>/data/redis/backup.sh</code></li>
<li>日志路径：<code>/var/spool/mail/root</code></li>
</ul>
<pre><code class="language-shell script"> # 1.编辑脚本
 cd /data/redis
 vim backup.sh
     #! /bin/bash
     PATH=/usr/local/redis/bin:$PATH
     redis-cli -p 6379 bgsave
     date=$(date +&quot;%Y%m%d&quot;)
     cp /data/redis/dump.rdb /data/redis/backup/dump$date.rdb
     echo &quot; 备份完成!&quot;
     DAYS=7
     find /data/redis/backup/ -mtime +$DAYS -delete #删除7天前的备份文件
     echo &quot;删除7天前数据备份完成！&quot;
 chmod +x backup.sh

# 2.添加定时任务,每天凌晨两点半备份
crontab -e
  30 2 * * * sh /data/redis/backup.sh
crontab -l
</code></pre>
<h4 id="将备份数据赋值到另外一台主机"><a class="header" href="#将备份数据赋值到另外一台主机">将备份数据赋值到另外一台主机</a></h4>
<p>详细操作参考： <a href="%E8%BF%90%E7%BB%B4%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB.html">mongodb备份</a>/将备份数据赋值到另外一台主机</p>
<h5 id="备份端配置"><a class="header" href="#备份端配置">备份端配置</a></h5>
<pre><code class="language-shell script"># 1.编辑服务器配置，末尾添加
vim /etc/rsyncd.conf
   #以下是全局配置
   [redisbackup]
   comment = sync rsync/data/redis/backup
   path = /data/redis/backup
   gid = root
   max connections = 10
   auth users = root
   secrets file = /etc/rsyncd.pass
   hosts allow = 172.31.49.33,127.0.0.1
   timeout = 600

 # 2.创建备份目录
mkdir /data/redis/backup
chown -R nobody:nobody /data/redis/backup

# 3.启动服务器 重启时记得删除rsyncd.pid：‘rm -rf /var/run/rsyncd.pid’
rsync --daemon --config=/etc/rsyncd.conf
</code></pre>
<h5 id="redis安装端"><a class="header" href="#redis安装端">redis安装端</a></h5>
<pre><code class="language-shell script"># 1.同步目录测试
rsync -auvrtzopgP --progress --password-file=/etc/rsync_client.pwd /data/redis/backup root@172.31.55.20::redisbackup

# 2.回到 每日备份 在backeup.sh中添加如下代码
rsync -auvrtzopgP --progress --password-file=/etc/rsync_client.pwd /data/redis/backup/dump$date.rdb root@172.31.55.20::redisbackup
</code></pre>
<h2 id="操作"><a class="header" href="#操作">操作</a></h2>
<h3 id="常用系统命令"><a class="header" href="#常用系统命令">常用系统命令</a></h3>
<pre><code class="language-shell script">cd /usr/local/redis/bin/
# 1.查看redis状态
./redis-cli -p 6379 --stat	

# 2.查看统计最大键
./redis-cli --bigkeys -p 6379	

# 3.监控redis操作
./redis-cli -p 6379 monitor	

# 4.延迟测试
./redis-cli -p 6379 --latency	

# 5.历史延迟
./redis-cli -p 6379 --latency-history 

# 6.数据备份  https://blog.csdn.net/rentian1/article/details/93845092
./redis-cli -p 6379 --rdb /data/redis/backup/dump20201104.rdb	
</code></pre>
<h3 id="性能测试"><a class="header" href="#性能测试">性能测试</a></h3>
<p>参考文档：<a href="https://redis.io/topics/benchmarks">https://redis.io/topics/benchmarks</a></p>
<pre><code class="language-shell script"># 1.测试
./redis-benchmark -p 6379 -q -n 100000
    PING_INLINE: 82918.74 requests per second
    PING_BULK: 81900.09 requests per second
    SET: 80128.20 requests per second
    GET: 82304.52 requests per second
    INCR: 84317.03 requests per second
    LPUSH: 78678.20 requests per second
    RPUSH: 84961.77 requests per second
    LPOP: 84388.19 requests per second
    RPOP: 83194.67 requests per second
    SADD: 85543.20 requests per second
    HSET: 84674.01 requests per second
    SPOP: 83682.01 requests per second
    LPUSH (needed to benchmark LRANGE): 82576.38 requests per second
    LRANGE_100 (first 100 elements): 48828.12 requests per second
    LRANGE_300 (first 300 elements): 24576.06 requests per second
    LRANGE_500 (first 450 elements): 18484.29 requests per second
    LRANGE_600 (first 600 elements): 15130.88 requests per second
    MSET (10 keys): 69156.30 requests per second

# 2.测试
./redis-benchmark -p 6379 -r 1000000 -n 2000000 -t get,set,lpush,lpop -P 16 -q
    SET: 547195.62 requests per second
    GET: 893655.06 requests per second
    LPUSH: 672721.12 requests per second
    LPOP: 736106.00 requests per second

# 3.测试
./redis-benchmark -p 6379 -r 1000000 -n 2000000 -t get,set,lpush,lpop -q
    SET: 83329.86 requests per second
    GET: 82736.94 requests per second
    LPUSH: 84409.55 requests per second
    LPOP: 83710.03 requests per second
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="elasticsearch"><a class="header" href="#elasticsearch">Elasticsearch</a></h1>
<p>  使用Elasticsearch进行集中日志查询管理；Linux主机，Docker，数据库等监控；应用程序性能，运行状态监控。</p>
<h2 id="安装-5"><a class="header" href="#安装-5">安装</a></h2>
<h3 id="1elasticsearch安装"><a class="header" href="#1elasticsearch安装">1.ElasticSearch安装</a></h3>
<p>参考文档：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.10/docker.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.10/docker.html</a></p>
<pre><code class="language-shell script"># 1.拉取镜像
docker pull docker.elastic.co/elasticsearch/elasticsearch:7.10.2

# 2.创建数据挂载目录并授权
cd /data
mkdir elasticsearch
chmod g+rwx elasticsearch
chgrp 0 elasticsearch

# 3.启动单个节点
docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -v /data/elasticsearch:/usr/share/elasticsearch/data -e &quot;discovery.type=single-node&quot; docker.elastic.co/elasticsearch/elasticsearch:7.10.2

# 4.测试查看信息
http://127.0.0.1:9200/_cat/nodes?v=true&amp;pretty
</code></pre>
<h3 id="2kibana安装"><a class="header" href="#2kibana安装">2.Kibana安装</a></h3>
<p>  Web查询客户端。参考文档：<a href="https://www.elastic.co/guide/en/kibana/7.10/docker.html">https://www.elastic.co/guide/en/kibana/7.10/docker.html</a></p>
<pre><code class="language-shell script"># 1.拉取镜像
docker pull docker.elastic.co/kibana/kibana:7.10.2

# 2.运行
docker run -d --name kibana --link elasticsearch:elasticsearch -p 5601:5601 docker.elastic.co/kibana/kibana:7.10.2

# 3.配置 
docker ps -f name=kibana
docker exec -it e431d5f8c92b /bin/sh
cd config
vi kibana.yml
# 3.1中文显示 添加如下内容
    i18n.locale: &quot;zh-CN&quot;

# 4.访问地址：http://127.0.0.1:5601/     
</code></pre>
<h3 id="3filebeat安装"><a class="header" href="#3filebeat安装">3.Filebeat安装</a></h3>
<p>  使用filebeat将本地日志文件传送到Elasticsearch数据库中。
参考文档：<a href="https://www.elastic.co/guide/en/beats/filebeat/7.10/filebeat-installation-configuration.html">https://www.elastic.co/guide/en/beats/filebeat/7.10/filebeat-installation-configuration.html</a><br />
配置文件参考：<a href="%E8%BF%90%E7%BB%B4%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93/Elasticsearch/filebeat.yml">filebeat.yml</a></p>
<pre><code class="language-shell script"># 1.下载运行包
cd /data/elasticsearch
curl -L -O https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-7.10.2-linux-x86_64.tar.gz
tar xzvf filebeat-7.10.2-linux-x86_64.tar.gz

# 2.连接elasticsearch
cd filebeat-7.10.2-linux-x86_64
vim filebeat.yml
    output.elasticsearch:
      hosts: [&quot;127.0.0.1:9200&quot;] 
    setup.kibana:
      host: &quot;127.0.0.1:5601&quot;
    
    - type: log
      enabled: true
      paths:
        - /var/log/*.log
        - /data/game/*/*.log

# 3.查看|使用模块
./filebeat modules list
./filebeat modules enable system
./filebeat setup -e

# 4.启动
sudo chown root filebeat.yml 
sudo chown root modules.d/system.yml 
nohup ./filebeat -e &gt;/dev/null  &amp;
#必须exit退出一下，不然filebeat进程运行一段时间会退出
exit
</code></pre>
<h3 id="4apm-server-安装"><a class="header" href="#4apm-server-安装">4.APM Server 安装</a></h3>
<p>  监控应用程序，安装的<code>7.10</code>版本最大支持到Jdk11，可用Skywalking替代。<br />
参考文档：<br />
<a href="https://www.elastic.co/guide/en/apm/get-started/7.10/install-and-run.html">https://www.elastic.co/guide/en/apm/get-started/7.10/install-and-run.html</a><br />
<a href="https://www.elastic.co/guide/en/apm/server/7.10/installing.html">https://www.elastic.co/guide/en/apm/server/7.10/installing.html</a><br />
<a href="https://www.elastic.co/guide/en/apm/server/7.10/running-on-docker.html">https://www.elastic.co/guide/en/apm/server/7.10/running-on-docker.html</a><br />
<a href="https://www.elastic.co/guide/en/apm/server/7.10/configuration-process.html">https://www.elastic.co/guide/en/apm/server/7.10/configuration-process.html</a><br />
<a href="http://47.108.13.34:40014/app/home#/tutorial/apm">http://47.108.13.34:40014/app/home#/tutorial/apm</a><br />
配置文件参考：hall/<a href="%E8%BF%90%E7%BB%B4%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93/hall1/apm-server.yml">apm-server.yml</a></p>
<pre><code class="language-shell script"># 1.下载并解压缩 APM Server
curl -L -O https://artifacts.elastic.co/downloads/apm-server/apm-server-7.10.2-x86_64.rpm
sudo rpm -vi apm-server-7.10.2-x86_64.rpm

# 2.启动
service apm-server start

# 3.常用配置
vim apm-server.yml 
    apm-server:
      host: &quot;0.0.0.0:8200
    kibana:
        enabled: true
        host: &quot;127.0.0.1:5601&quot;
    rum:
        enabled: true
        
    output.elasticsearch:
      hosts: [&quot;127.0.0.1:9200&quot;]
</code></pre>
<h3 id="5heartbeat-安装"><a class="header" href="#5heartbeat-安装">5.Heartbeat 安装</a></h3>
<p>  监控引用程序是否在运行状态中，实际生产中使用较少。例如应用程序像InfluxDB写数据，结合Grafana来监控。
参考文档：<a href="https://www.elastic.co/guide/en/observability/7.10/ingest-uptime.html">https://www.elastic.co/guide/en/observability/7.10/ingest-uptime.html</a><br />
配置文件参考：<a href="%E8%BF%90%E7%BB%B4%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%BA%93/Elasticsearch/heartbeat.yml">heartbeat.yml</a></p>
<pre><code class="language-shell script"># 1.下载运行包
cd /data/elasticsearch
curl -L -O https://artifacts.elastic.co/downloads/beats/heartbeat/heartbeat-7.10.2-linux-x86_64.tar.gz
tar xzvf heartbeat-7.10.2-linux-x86_64.tar.gz

# 2.连接elasticsearch
cd heartbeat-7.10.2-linux-x86_64
vim heartbeat.yml
    heartbeat.monitors:
    - type: http
      id: ElasticSearch
      name: ElasticSearch
      urls: [&quot;http://127.0.0.1:9200&quot;]
      schedule: '@every 10s'
    - type: tcp
      id: GateClient1
      name: GateClient1
      schedule: '@every 5s'
      hosts: [&quot;127.0.0.1:2012&quot;]
      mode: any

    output.elasticsearch:
      hosts: [&quot;127.0.0.1:9200&quot;] 
    setup.kibana:
      host: &quot;127.0.0.1:5601&quot;

# 3.查看|使用模块
./heartbeat setup -e

# 4.启动
sudo chown root heartbeat.yml 
nohup ./heartbeat -e &gt;/dev/null  &amp;
#必须exit退出一下，不然heartbeat进程运行一段时间会退出
exit

# 5.配置http，tcp网络监控
cd monitors.d
cp sample.http.yml.disabled register.http.yml
vim register.http.yml
</code></pre>
<h3 id="6metricbeat安装"><a class="header" href="#6metricbeat安装">6.Metricbeat安装</a></h3>
<p>  监控linux服务器内存、CPU、网络、磁盘，MongoDB数据库，Docker等，可使用InfluxDB替代。
参考文档：<a href="https://www.elastic.co/guide/en/beats/metricbeat/7.10/metricbeat-installation-configuration.html">https://www.elastic.co/guide/en/beats/metricbeat/7.10/metricbeat-installation-configuration.html</a></p>
<pre><code class="language-shell script"># 1.下载运行包
cd /data/elasticsearch
mkdir metricbeat
curl -L -O https://artifacts.elastic.co/downloads/beats/metricbeat/metricbeat-7.10.2-linux-x86_64.tar.gz
tar xzvf metricbeat-7.10.2-linux-x86_64.tar.gz

# 2.连接elasticsearch
cd metricbeat-7.10.2-linux-x86_64
vim metricbeat.yml

    output.elasticsearch:
      hosts: [&quot;localhost:9200&quot;] 
    setup.kibana:
      host: &quot;localhost:5601&quot;
 cd modules.d
 #修改mongodb数据库连接地址用户名和密码
 vim mongodb.yml 
 

# 3.查看|使用模块（系统，docker，mongodb）
./metricbeat modules list
./metricbeat modules enable system mongodb docker
./metricbeat setup -e

# 4.启动
sudo chown root metricbeat.yml 
sudo chown root modules.d/system.yml 
sudo chown root modules.d/docker.yml 
sudo chown root modules.d/mongodb.yml 
nohup ./metricbeat -e &gt;/dev/null  &amp;
#必须exit退出一下，不然filebeat进程运行一段时间会退出
exit
</code></pre>
<h2 id="查询"><a class="header" href="#查询">查询</a></h2>
<h4 id="1查询匹配的日志内容"><a class="header" href="#1查询匹配的日志内容">1.查询匹配的日志内容</a></h4>
<pre><code class="language-shell script">curl -X GET &quot;localhost:20011/filebeat-*/_search?pretty&quot; -H 'Content-Type: application/json' -d'
{
  &quot;query&quot;: {
    &quot;match&quot;: {
      &quot;message&quot;: &quot;国家&quot;
    }
  }
}
'
</code></pre>
<h4 id="2kibana查询"><a class="header" href="#2kibana查询">2.kibana查询</a></h4>
<p>参考文档：<br />
<a href="https://www.jianshu.com/p/9d511ea3a49d">https://www.jianshu.com/p/9d511ea3a49d</a><br />
<a href="https://blog.csdn.net/jack1liu/article/details/102531714">https://blog.csdn.net/jack1liu/article/details/102531714</a></p>
<ul>
<li>全词查询<br />
message:&quot;正常退出游戏&quot;</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="监控系统"><a class="header" href="#监控系统">监控系统</a></h1>
<h3 id="todo-8"><a class="header" href="#todo-8">TODO：</a></h3>
<ul>
<li>Sentry异常日志</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grafana"><a class="header" href="#grafana">Grafana</a></h1>
<h2 id="安装-6"><a class="header" href="#安装-6">安装</a></h2>
<p>1.运行docker镜像</p>
<pre><code class="language-shell script">docker run -d --name=grafana -p 3000:3000 grafana/grafana
</code></pre>
<p>2.访问地址 <a href="http://192.168.0.1:3000/">http://192.168.0.1:3000/</a> ，账号admin 密码admin<br />
3.修改配置文件</p>
<pre><code class="language-shell script"># 1.进入docker
docker exec --user root -it a6882651c45b /bin/sh

# 2.修改默认URL地址,重启docker容器
cd config
vi defaults.ini
root_url = %(protocol)s://192.168.0.1:3000
</code></pre>
<p>4.钉钉监控预警通知<br />
在钉钉群群创建Webhook如下机器人<br />
<img src="%E8%BF%90%E7%BB%B4%E7%AF%87/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/grafana/dingdin_robot_webhook.png" alt="钉钉机器人创建" /></p>
<p>复制URL到Grafana设置通知渠道
<img src="%E8%BF%90%E7%BB%B4%E7%AF%87/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/grafana/grafana_notification_channel.png" alt="Grafana通知渠道" /></p>
<p>注意： 预警文本需要包含钉钉设置的关键字</p>
<p>5.安装redis数据源插件
进入docker运行命令<code>grafana-cli plugins install redis-datasource</code>重启服务器</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="influxdb"><a class="header" href="#influxdb">InfluxDB</a></h1>
<h2 id="安装-7"><a class="header" href="#安装-7">安装</a></h2>
<h3 id="1-influxdb安装"><a class="header" href="#1-influxdb安装">1. InfluxDB安装</a></h3>
<ol>
<li>docker安装命令：</li>
</ol>
<pre><code class="language-shell script"> docker run -d --name influxdb -p 8086:8086 --restart=always -e TZ=&quot;America/Chicago&quot; quay.io/influxdb/influxdb:v2.0.3 --reporting-disabled
</code></pre>
<ol start="2">
<li>浏览器访问：http://127.0.0.1:8086/<br />
账号：root 密码： 123456</li>
</ol>
<h3 id="2-telegraf安装"><a class="header" href="#2-telegraf安装">2. Telegraf安装</a></h3>
<p>参考地址：<a href="https://docs.influxdata.com/telegraf/v1.17/introduction/installation/">https://docs.influxdata.com/telegraf/v1.17/introduction/installation/</a><br />
配置文件路径：<code>/etc/telegraf/telegraf.conf</code></p>
<pre><code class="language-shell script"># 1.编辑安装源
cat &lt;&lt;EOF | sudo tee /etc/yum.repos.d/influxdb.repo
[influxdb]
name = InfluxDB Repository - RHEL \$releasever
baseurl = https://repos.influxdata.com/rhel/\$releasever/\$basearch/stable
enabled = 1
gpgcheck = 1
gpgkey = https://repos.influxdata.com/influxdb.key
EOF

# 2.安装
sudo yum install telegraf

# 3.启动
sudo systemctl start telegraf

# 4.停止（注意正式服需要停止默认服务，没有配置，开机自动启动）
systemctl stop telegraf
</code></pre>
<h3 id="3-telegraf配置"><a class="header" href="#3-telegraf配置">3. Telegraf配置</a></h3>
<ol>
<li>自动配置<br />
服务器监控，docker，redis为自动配置<br />
参考：<a href="https://docs.influxdata.com/influxdb/v2.0/write-data/no-code/use-telegraf/auto-config/">https://docs.influxdata.com/influxdb/v2.0/write-data/no-code/use-telegraf/auto-config/</a></li>
<li>手动配置<br />
参考：<a href="https://docs.influxdata.com/influxdb/v2.0/write-data/no-code/use-telegraf/manual-config/">https://docs.influxdata.com/influxdb/v2.0/write-data/no-code/use-telegraf/manual-config/</a></li>
</ol>
<h3 id="4-删除数据库"><a class="header" href="#4-删除数据库">4. 删除数据库</a></h3>
<p>参考文档：<a href="https://docs.influxdata.com/influxdb/v2.0/write-data/delete-data/">https://docs.influxdata.com/influxdb/v2.0/write-data/delete-data/</a></p>
<pre><code class="language-shell script"># 1.进入容器
docker exec -it 7df65a67e3ba /bin/bash
    
# 2.删除命令
influx delete --org game-aws --bucket game-server \
  --token uf6uM-veNG_RcJVXdWfloYodv3pNFMQBSHxh9br8QMg9Qsr_6aT1pif_cdCiWAZ3mU5vIEc9K_2daCtK_V9g== \
  --start '1970-01-01T00:00:00Z' \
  --stop '2021-11-14T00:00:00Z' \
  --predicate '_measurement=&quot;game_info&quot;'
</code></pre>
<h3 id="5-数据监控"><a class="header" href="#5-数据监控">5. 数据监控</a></h3>
<p>  配置文件参考：
<a href="%E8%BF%90%E7%BB%B4%E7%AF%87/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/influxdb/LinuxTelegraf.conf">Linux</a>、<a href="%E8%BF%90%E7%BB%B4%E7%AF%87/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/influxdb/MongodbTelegraf.conf">MongoDB</a>、
<a href="%E8%BF%90%E7%BB%B4%E7%AF%87/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/influxdb/RedisTelegraf.conf">Redis</a>、<a href="%E8%BF%90%E7%BB%B4%E7%AF%87/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/influxdb/DockerTelegraf.conf">Docker</a></p>
<pre><code class="language-shell script"># 1.设置环境变量
export INFLUX_TOKEN=m4jOs8bnYI05Gg7bXCqdKWVOQtTzZBDJby1pMfvKgvrq_sFxxmB3KvZjGzaZ1iXw-a0KnQSkib4i5euvzQw==

# 2.启动telegraf
nohup telegraf --config http://127.0.0.1:8086/api/v2/telegrafs/07a13141c3f98000 &gt;/dev/null  &amp;

# 3. linux本地配置启动
nohup telegraf --config /data/telegraf/LinuxTelegraf.conf &gt;/dev/null  &amp;
nohup telegraf --config /data/mongo/MongodbTelegraf.conf &gt;/dev/null  &amp;
nohup telegraf --config /data/mongo/Rediselegraf.conf &gt;/dev/null  &amp;
nohup telegraf --config /data/mongo/DockerTelegraf.conf &gt;/dev/null  &amp;

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="skywalking"><a class="header" href="#skywalking">Skywalking</a></h1>
<p>  监控java 进程信息，elasticsearch apm 有类似功能，但是只支持到了jdk11。</p>
<h2 id="安裝"><a class="header" href="#安裝">安裝</a></h2>
<pre><code class="language-shell script"># 1.下载
cd /data/
wget https://archive.apache.org/dist/skywalking/8.7.0/apache-skywalking-apm-es7-8.7.0.tar.gz
tar -xzvf apache-skywalking-apm-es7-8.7.0.tar.gzrm
rm -rf apache-skywalking-apm-es7-8.7.0.tar.gz

# 2.配置 数据存储为elasticsearch
cd apache-skywalking-apm-bin-es7/config
vim application.yml
    storage:
    selector: ${SW_STORAGE:elasticsearch7}
    
    elasticsearch7:
      nameSpace: ${SW_NAMESPACE:&quot;&quot;}
      clusterNodes: ${SW_STORAGE_ES_CLUSTER_NODES:127.0.0.1:9000}
      
  # 3.配置web查看端口
  cd  apache-skywalking-apm-bin-es7/webapp
  vim webapp.yml
  
      server:
        port: 9001
        
  # 4.启动
  cd apache-skywalking-apm-bin-es7/bin
  ./startup.sh
</code></pre>
<h2 id="java-docker-agent-配置"><a class="header" href="#java-docker-agent-配置">Java docker agent 配置</a></h2>
<p>参考：<a href="https://blog.csdn.net/gre_999/article/details/101726367">https://blog.csdn.net/gre_999/article/details/101726367</a></p>
<p>见项目dockerfile文件和docker启动脚本</p>
<h2 id="常见问题-2"><a class="header" href="#常见问题-2">常见问题</a></h2>
<h3 id="1谷歌浏览器不显示仪表盘数据"><a class="header" href="#1谷歌浏览器不显示仪表盘数据">1.谷歌浏览器不显示仪表盘数据</a></h3>
<pre><code>清除缓存，或者换个浏览器，使用Edge
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sentry"><a class="header" href="#sentry">Sentry</a></h1>
<p>  提供错误日志查询，预警，文档参考：<a href="https://docs.sentry.io/product/">https://docs.sentry.io/product/</a></p>
<h2 id="安装-8"><a class="header" href="#安装-8">安装</a></h2>
<p>  官网只看见linux docker-compose安装教程，而且对docker和docker-compose有要求，sentry服务太多，较耗内存。安装脚本<a href="https://github.com/getsentry/self-hosted/releases">下载</a> ,参考文档：<br />
<a href="https://github.com/getsentry/self-hosted/releases">https://github.com/getsentry/self-hosted/releases</a><br />
<a href="https://develop.sentry.dev/self-hosted/">https://develop.sentry.dev/self-hosted/</a></p>
<pre><code class="language-shell script"># 1.解押及安装
mkdir /data/sentry
unzip self-hosted-22.8.0.zip
cd self-hosted-22.8.0
./install.sh

# 2.启动 访问地址：&lt;http://127.0.0.1:9000/&gt;
docker-compose up -d

# 3.停止
docker-compose down
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="诊断工具"><a class="header" href="#诊断工具">诊断工具</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arthas"><a class="header" href="#arthas">Arthas</a></h1>
<p>  进行线上Java应用问题排查。参考文档：</p>
<ul>
<li><a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li>
<li><a href="https://developer.aliyun.com/article/921780">https://developer.aliyun.com/article/921780</a></li>
</ul>
<h2 id="环境部署"><a class="header" href="#环境部署">环境部署</a></h2>
<pre><code class="language-shell script"># 1.运行，因为有多个java版本，需要指定路径
cd /data/java/
/data/java/jdk-14.0.2/bin/java -jar arthas-boot.jar --target-ip 0.0.0.0
</code></pre>
<h2 id="命令参考"><a class="header" href="#命令参考">命令参考</a></h2>
<h3 id="1docker运行-arthas"><a class="header" href="#1docker运行-arthas">1.docker运行 arthas</a></h3>
<p>docker里出现arthas无法工作的问题，是因为应用没有安装 JDK ，而是安装了 JRE</p>
<pre><code class="language-shell script"># 1.docker 运行（官方使用，实际不行，docker容器没有wget 命令）
docker exec -it  ${containerId} /bin/bash -c &quot;wget https://arthas.aliyun.com/arthas-boot.jar &amp;&amp; java -jar arthas-boot.jar&quot;

# 2.使用curl 方式进行
docker exec -it bcd75 /bin/bash
curl https://arthas.aliyun.com/arthas-boot.jar --output arthas-boot.jar
java -jar arthas-boot.jar
    dashboard
    thread -all
</code></pre>
<h3 id="2仪表盘查看概要信息"><a class="header" href="#2仪表盘查看概要信息">2.仪表盘查看概要信息</a></h3>
<pre><code>dashboard
</code></pre>
<h3 id="3查看线程"><a class="header" href="#3查看线程">3.查看线程</a></h3>
<ul>
<li>thread -b, 找出当前阻塞其他线程的线程</li>
<li>thread –all, 显示所有匹配的线程</li>
<li>thread -n 3 3个最忙的线程</li>
<li>thread 49 显示线程id为49的堆栈信息</li>
<li>thread --state WAITING 查看等待状态的线程</li>
</ul>
<h3 id="4查看内存"><a class="header" href="#4查看内存">4.查看内存</a></h3>
<ul>
<li>memory 查看内存信息</li>
</ul>
<h3 id="5日志修改"><a class="header" href="#5日志修改">5.日志修改</a></h3>
<pre><code class="language-shell script"># 1.查看指定名称日志
logger -n com.dls

# 2.修改日志级别
logger --name com.dls --level info
</code></pre>
<h3 id="6调优性能bug排查"><a class="header" href="#6调优性能bug排查">6.调优，性能、bug排查</a></h3>
<pre><code class="language-shell script"># 1.查看类信息
sc -d com.dls.slots.gate.service.GateService

# 2.查看方法信息
sm -d com.dls.slots.gate.service.GateService init

# 3.查看类加载信息
classloader

# 4.监控方法执行次数和耗时
monitor -c 5 com.dls.slots.gate.tcp.user.UserTcpServerHandler channelRead

# 5.跟踪函数执行，统计耗时
trace com.dls.slots.gate.tcp.user.UserTcpServerHandler channelRead

# 6.方法调用栈
stack com.dls.slots.gate.tcp.user.UserTcpServerHandler channelRead

# 7. 查看方法返回值，参数，执行时间，是否异常等
tt -t com.dls.slots.gate.sturct.User sendToUser
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="三方组件"><a class="header" href="#三方组件">三方组件</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nginx"><a class="header" href="#nginx">Nginx</a></h1>
<h2 id="安装-9"><a class="header" href="#安装-9">安装</a></h2>
<p>安装参考：<a href="http://nginx.org/en/linux_packages.html">http://nginx.org/en/linux_packages.html</a>
配置路径：<code>/etc/nginx/</code></p>
<pre><code class="language-shell script"># 1.安装前置软件
sudo yum install yum-utils
vim /etc/yum.repos.d/nginx.repo
    [nginx-stable]
    name=nginx stable repo
    baseurl=http://nginx.org/packages/centos/$releasever/$basearch/
    gpgcheck=1
    enabled=1
    gpgkey=https://nginx.org/keys/nginx_signing.key
    module_hotfixes=true
    
    [nginx-mainline]
    name=nginx mainline repo
    baseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/
    gpgcheck=1
    enabled=0
    gpgkey=https://nginx.org/keys/nginx_signing.key
    module_hotfixes=true

# 2.安装
sudo yum install nginx

# 3.退出
nginx -s quit
service nginx stop
# 4.启动
nginx
service nginx start
# 5.重载配置
nginx -s reload
sudo systemctl reload nginx
# 6.重启
nginx -c /etc/nginx/nginx.conf
</code></pre>
<h2 id="配置"><a class="header" href="#配置">配置</a></h2>
<h3 id="文件下载"><a class="header" href="#文件下载">文件下载</a></h3>
<pre><code class="language-shell script"># 1.创建目录文件
mkdir /data/download
 
# 2.配置download.conf
vim download.conf
   server {
       listen       8012;
       listen  [::]:8012;
       auth_basic           &quot;input password&quot;;
       auth_basic_user_file /etc/nginx/conf.d/password;
       location ^~ /download/ {
          #需要下载的文件存放的目录
           alias  /data/download/;
           sendfile on;
           autoindex on;  # 开启目录文件列表
           autoindex_exact_size on;  # 显示出文件的确切大小，单位是bytes
           autoindex_localtime on;  # 显示的文件时间为文件的服务器时间
           charset utf-8,gbk;  # 避免中文乱码
       }
   }
 
# 3.加载配置
nginx -s reload
</code></pre>
<h2 id="常见问题-3"><a class="header" href="#常见问题-3">常见问题</a></h2>
<ul>
<li><strong>bind() to 0.0.0.0:XXXX failed (13: Permission denied)</strong></li>
</ul>
<pre><code># 1.查看http可访问端口
semanage port -l | grep http_port_t
# 2.设置http访问端口
semanage port -a -t http_port_t  -p tcp 8090
</code></pre>
<p>参考：<a href="https://blog.csdn.net/cbmljs/article/details/88574122">https://blog.csdn.net/cbmljs/article/details/88574122</a></p>
<p>代理和被代理端口都需要设置</p>
<ul>
<li>
<p><strong>recv() failed (104: Connection reset by peer) while reading response header from upstream, client:</strong>
game-manage 项目docker端口映射错误，导致不能访问</p>
</li>
<li>
<p><strong>502 no live upstreams while connecting to upstream</strong>
大厅报错，未正常返回数据，导致nginx连接耗尽<br />
配置 <code>keepalive 256;</code> 共用长链接<br />
参考：<a href="https://blog.csdn.net/donkeyboy001/article/details/119548514">https://blog.csdn.net/donkeyboy001/article/details/119548514</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zookeeper"><a class="header" href="#zookeeper">Zookeeper</a></h1>
<h2 id="安装-10"><a class="header" href="#安装-10">安装</a></h2>
<h3 id="docker-安装"><a class="header" href="#docker-安装">Docker 安装</a></h3>
<p>参考文档：<a href="https://hub.docker.com/_/zookeeper">https://hub.docker.com/_/zookeeper</a></p>
<pre><code># 1.拉取镜像并运行
docker run --name zookeeper -p 2181:2181 --restart always -d zookeeper
</code></pre>
<h2 id="控制台命令"><a class="header" href="#控制台命令">控制台命令</a></h2>
<pre><code class="language-shell script"># 1.进入服务器
cd /data/apache-zookeeper-3.6.1-bin/bin

# 2.连接zookeeper
./zkCli.sh -timeout 5000 -server 127.0.0.1:2181

# 3.查看帮助命令
h

# 4.查看节点及状态
ls /
stat game

# 6.创建&amp;获取路径数据
create /game/online/log/grpc 127.0.0.1:8305,127.0.0.1:8306
get /game/online/log/grpc

# 7.退出
quit
</code></pre>
<h2 id="参数配置"><a class="header" href="#参数配置">参数配置</a></h2>
<h3 id="最大连接数配置"><a class="header" href="#最大连接数配置">最大连接数配置</a></h3>
<p>  最大连接数默认每台主机最大连接60个客户端</p>
<pre><code class="language-shell script"># 1.进入目录
cd /data/apache-zookeeper-3.6.1-bin/conf

# 2.编辑
vim zoo.cfg 
    maxClientCnxns=600

# 3.重启
./zkServer.sh restart

</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
